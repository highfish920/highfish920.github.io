<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>highfish920的博客</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-31T10:16:56.490Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>highfish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GIT篇---4.使用 diff 查看修改了哪些代码，分支管理(Windows系统)</title>
    <link href="http://yoursite.com/2020/08/31/git4/"/>
    <id>http://yoursite.com/2020/08/31/git4/</id>
    <published>2020-08-31T10:12:16.927Z</published>
    <updated>2020-08-31T10:16:56.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-名词定义"><a href="#1-名词定义" class="headerlink" title="1.名词定义"></a>1.名词定义</h2><a id="more"></a><p>在学习 Git 的diff命令之前，我们先来统一 一下两个名词的理解，分别是工作区和暂存区。</p><h3 id="1-1-工作区"><a href="#1-1-工作区" class="headerlink" title="1.1 工作区"></a>1.1 工作区</h3><p>工作区，指的是当前正在编辑的文件，将还没有修改的内容通过git add命令暂存起来；比如我现在修改了index.php文件中的一行代码，没有执行git add index.php命令，那么 index.php 便处于工作区状态。</p><h3 id="1-2-暂存区"><a href="#1-2-暂存区" class="headerlink" title="1.2 暂存区"></a>1.2 暂存区</h3><p>暂存区，指的是文件修改之后并且通过git add命令临时存储到版本记录里了，但还没有正式通过git commit提交的阶段；比如我现在新增一个test.php文件，使用了git add test.php命令，那么此时， test.php 文件的改动就已经进入到了暂存区。</p><h3 id="1-3-比较工作区变动"><a href="#1-3-比较工作区变动" class="headerlink" title="1.3 比较工作区变动"></a>1.3 比较工作区变动</h3><p>现在我编辑了index.php文件，并且在里面加入了内容，如果我想通过 git 命令查看增加了哪些内容，参考命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff </span><br></pre></td></tr></table></figure><h3 id="1-4-比较暂存区变动"><a href="#1-4-比较暂存区变动" class="headerlink" title="1.4  比较暂存区变动"></a>1.4  比较暂存区变动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached  diff.php</span><br></pre></td></tr></table></figure><h3 id="1-5-与指定记录比较"><a href="#1-5-与指定记录比较" class="headerlink" title="1.5 与指定记录比较"></a>1.5 与指定记录比较</h3><p>有些时候，我们可能需要代码和历史的某一个版本进行比较，这个时候你可以先通过<code>git log</code></p><h3 id="1-6-工作区比较"><a href="#1-6-工作区比较" class="headerlink" title="1.6 工作区比较"></a>1.6 工作区比较</h3><p>将要比较的 hash 值复制下来，然后执行如下所示命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff <span class="built_in">hash</span>值</span><br></pre></td></tr></table></figure><h3 id="1-7-暂存区比较"><a href="#1-7-暂存区比较" class="headerlink" title="1.7 暂存区比较"></a>1.7 暂存区比较</h3><p>有些时候，我们想把暂存区的改动和指定记录进行对比，那么在命令中加入–cached 即可，参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached <span class="built_in">hash</span>值</span><br></pre></td></tr></table></figure><h3 id="1-8-与最新版本库比较"><a href="#1-8-与最新版本库比较" class="headerlink" title="1.8 与最新版本库比较"></a>1.8 与最新版本库比较</h3><p>很多时候，我们只需要将未正式提交的代码（包含工作区与暂存区）与最新的 commit 记录进行比较，虽然也可以通过指定 commit 的 hash 值进行，但是却很不方便，需要先获取到 hash 值，这里介绍一个简单的方法，可以通过git diff HEAD命令方式快速对比，参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><p>在执行的命令中，HEAD指的是当前所在的分支名，如果你想比较其他分支也可以将 HEAD 改成其他分支名。</p><h3 id="1-9-比较两个历史记录"><a href="#1-9-比较两个历史记录" class="headerlink" title="1.9 比较两个历史记录"></a>1.9 比较两个历史记录</h3><p>有时候，可能会需要查看某一次提交记录修改了什么内容，这个时候就需要将两个历史记录进行比较；首先通过git log命令获取到需要查看的记录 hash 值，然后再找到这个记录的上一个版本的 hash 值，拼接的参考命令如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff <span class="built_in">hash</span>值1  <span class="built_in">hash</span>值2</span><br></pre></td></tr></table></figure><h2 id="2-分支管理"><a href="#2-分支管理" class="headerlink" title="2.分支管理"></a>2.分支管理</h2><h3 id="2-1查看分支"><a href="#2-1查看分支" class="headerlink" title="2.1查看分支"></a>2.1查看分支</h3><p>在学习分支管理之前，我们先来查看一下分支。分支分为两种，一种是本地已经存在的，还有一种是服务器上有，但本地不存在的分支，查看的方式稍有区别。</p><h3 id="2-2查看本地的分支"><a href="#2-2查看本地的分支" class="headerlink" title="2.2查看本地的分支"></a>2.2查看本地的分支</h3><p>Git 查看分支的命令为 git branch，在不带参数的情况下，默认查看到的是本地分支列表，参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch </span><br></pre></td></tr></table></figure><h4 id="2-3查看所有分支"><a href="#2-3查看所有分支" class="headerlink" title="2.3查看所有分支"></a>2.3查看所有分支</h4><p>在 git branch 中再加入一个 -a 参数，可以理解为 all 的意思，就是查看本地的分支和远程的所有分支，参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a </span><br></pre></td></tr></table></figure><h3 id="2-4新建分支"><a href="#2-4新建分支" class="headerlink" title="2.4新建分支"></a>2.4新建分支</h3><p>新建分支有两种情况，第一种是远程已经有的分支，需要把它在本地也同样创建一份；还有一种是新建一个远端和本地都不存在的分支。</p><h4 id="2-4-1导入远程分支"><a href="#2-4-1导入远程分支" class="headerlink" title="2.4.1导入远程分支"></a>2.4.1导入远程分支</h4><p>把远程分支在本地创建，可以通过 <code>git checkout</code> 分支名 命令进行，<strong>这个命令其实是切换分支用的</strong>。但当它发现你本地不存在这个分支，会自动找到远程对应的分支然后在本地进行创建，参考命令如下所示：<br>（在执行前，需要确保这个分支在远程或者本地已经存在）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>切换分支成功之后，会提示已经切换分支成功，以及提示你当前分支对应远程的分支名</p><h4 id="2-4-2-新建本地分支"><a href="#2-4-2-新建本地分支" class="headerlink" title="2.4.2 新建本地分支"></a>2.4.2 新建本地分支</h4><p>新建一个远程和本地都不存在的分支方式，和切换分支区别不大，只需要在 <code>git checkout</code> 分支名 中间加入参数 <code>-b</code> 即可。通过这种方式，创建的分支结构和内容会与当前所在的分支一模一样，也就是说，它其实就是复制了当前的分支，参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>在提示中，同样可以看到会告诉你切换分支成功，但没有提示你对应远程的分支名，因为远程现在还不存在这个分支。所以你此时如果使用 <code>git push</code> 是不能直接推送的，需要在第一次推送的时候指定远程分支名，参考命令如下图所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --<span class="built_in">set</span>-upstream origin <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="2-5合并分支"><a href="#2-5合并分支" class="headerlink" title="2.5合并分支"></a>2.5合并分支</h3><p>假设我们现在有三个分支，分别是:master生产环境、develop开发环境、test bug 修复分支。现在我在 test 分支中修复了 BUG，需要发布到线上生产服务器上，那么我们就可以通过合并分支的方式将test分支的代码合并到 master 分支中去。</p><h4 id="2-5-1-合并代码"><a href="#2-5-1-合并代码" class="headerlink" title="2.5.1 合并代码"></a>2.5.1 合并代码</h4><p>合并的时候， Git 会对比两个分支代码的差异，当 test 分支处于比较新的状态时候，Git 会将 test 分支的代码和提交记录复制到 master 分支中来，合并代码的参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h4 id="2-5-2-查看合并记录"><a href="#2-5-2-查看合并记录" class="headerlink" title="2.5.2 查看合并记录"></a>2.5.2 查看合并记录</h4><p>在代码合并之后，可以通过 <code>git log</code> 方式查看到合并记录，参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h4 id="2-5-3-删除分支"><a href="#2-5-3-删除分支" class="headerlink" title="2.5.3  删除分支"></a>2.5.3  删除分支</h4><p>一般用来修复 BUG 的分支，我们可以把它当做是一个临时分支，当合并到 master 之后，就可以删除掉它了，这样可以减少 Git 仓库的体积。删除分支有两种方式，普通删除和强制删除。</p><h5 id="2-5-3-1-普通删除"><a href="#2-5-3-1-普通删除" class="headerlink" title="2.5.3.1 普通删除"></a>2.5.3.1 普通删除</h5><p>Git 中删除分支的命令为<code>git branch -d</code> 分支名，其中参数-d代表的是普通删除。一般情况下，删除使用普通删除即可。普通删除相对来说比较安全，避免造成数据丢失的情况，参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h5 id="2-5-3-2-强制删除"><a href="#2-5-3-2-强制删除" class="headerlink" title="2.5.3.2 强制删除"></a>2.5.3.2 强制删除</h5><p>在极少数情况下你可能会遇到普通删除无法将分支删除的情况，这个时候你可以将-d替换成-D，这样就可以进行强制删除，参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>本文整理自 <a href="http://www.imooc.com/read/51">http://www.imooc.com/read/51</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-名词定义&quot;&gt;&lt;a href=&quot;#1-名词定义&quot; class=&quot;headerlink&quot; title=&quot;1.名词定义&quot;&gt;&lt;/a&gt;1.名词定义&lt;/h2&gt;</summary>
    
    
    
    <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
    <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GIT篇---3.如何把修改后的代码提交到远程仓库(Windows系统)</title>
    <link href="http://yoursite.com/2020/08/31/git3/"/>
    <id>http://yoursite.com/2020/08/31/git3/</id>
    <published>2020-08-31T09:48:53.962Z</published>
    <updated>2020-08-31T10:17:03.723Z</updated>
    
    <content type="html"><![CDATA[<h6 id="将代码提交到远程仓库中，其实通常只需要两条命令即可，首先是提交到本地，然后再将本地的记录推送到远端。但在实际工作中，为了防止本地仓库和远程仓库出现冲突，一般先让把远程代码同步到本地代码，让本地代码保持最新，然后再提交改动到本地，最后进行推送。"><a href="#将代码提交到远程仓库中，其实通常只需要两条命令即可，首先是提交到本地，然后再将本地的记录推送到远端。但在实际工作中，为了防止本地仓库和远程仓库出现冲突，一般先让把远程代码同步到本地代码，让本地代码保持最新，然后再提交改动到本地，最后进行推送。" class="headerlink" title="将代码提交到远程仓库中，其实通常只需要两条命令即可，首先是提交到本地，然后再将本地的记录推送到远端。但在实际工作中，为了防止本地仓库和远程仓库出现冲突，一般先让把远程代码同步到本地代码，让本地代码保持最新，然后再提交改动到本地，最后进行推送。"></a>将代码提交到远程仓库中，其实通常只需要两条命令即可，首先是提交到本地，然后再将本地的记录推送到远端。但在实际工作中，为了防止本地仓库和远程仓库出现冲突，一般先让把远程代码同步到本地代码，让本地代码保持最新，然后再提交改动到本地，最后进行推送。</h6><a id="more"></a><h2 id="1-同步远程代码"><a href="#1-同步远程代码" class="headerlink" title="1.同步远程代码"></a>1.同步远程代码</h2><p>一个远程仓库有可能有多人有权限推送，所以存在远程代码比你本地仓库更新，因此在提交代码之前需要先拉取服务器代码，让本地仓库保持最新的版本记录；这样做的目的是为了防止当你提交代码之后，推送到远端出现代码冲突问题，拉取远程代码参考命令如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull </span><br></pre></td></tr></table></figure><h2 id="2-检查改动文件"><a href="#2-检查改动文件" class="headerlink" title="2.检查改动文件"></a>2.检查改动文件</h2><p>当远端最新的代码拉下来之后，我们最好（非必须，建议每次提交前检查）通过git status命令检查一下有哪些文件被改动了，参考命令如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>在终端执行完命令之后，有删除的、有添加的、也有修改内容的</p><ul><li>Untracked: 未跟踪,一般为新增文件，此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作.</li><li>deleted： 文件已删除，本地删除，服务器上还没有删除.</li><li>renamed：文件名称被改变<br>如果发现无意中编辑了某一个文件，但实际上并不想改变它，这里可以使用git checkout 文件名来撤销更改，参考命令如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout README.md</span><br></pre></td></tr></table></figure><p>撤销后，再次使用<code>git status</code>进行查看变动</p><h2 id="3-添加文件到缓存"><a href="#3-添加文件到缓存" class="headerlink" title="3.添加文件到缓存"></a>3.添加文件到缓存</h2><p>通过检查并将不需要改动的代码恢复后，就可以开始将需要提交的文件添加到暂存区中，添加文件到暂存区可以指定添加文件或目录，或者一次性添加全部改动到缓存。<br>先来看看提交指定文件或目录至缓存的格式，参考命令如下：<code>git add index.php</code><br>也可以使用刚才的命令将 app目录,提交到缓存中去，参考命令如下：<code>git add app</code><br>如果一次性添加所有文件，那么可以把命令这样写<code>git add .</code>(记住有点)</p><h2 id="4-提交代码"><a href="#4-提交代码" class="headerlink" title="4. 提交代码"></a>4. 提交代码</h2><p>当你将所需要提交的代码都添加到缓存区域后，接下来就可以将代码提交到本地仓库中，参考命令如下所示 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit . -m “这是备注信息”</span><br></pre></td></tr></table></figure><h2 id="5-推送代码"><a href="#5-推送代码" class="headerlink" title="5.推送代码"></a>5.推送代码</h2><p>当代码提交之后，在本地的工作就已经完成了，此时为了让其他人拉取你的代码，通常还需要将代码推送到远程仓库，这里我告诉大家最简单的方式，参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>本文整理自 <a href="http://www.imooc.com/read/51">http://www.imooc.com/read/51</a></p>]]></content>
    
    
    <summary type="html">&lt;h6 id=&quot;将代码提交到远程仓库中，其实通常只需要两条命令即可，首先是提交到本地，然后再将本地的记录推送到远端。但在实际工作中，为了防止本地仓库和远程仓库出现冲突，一般先让把远程代码同步到本地代码，让本地代码保持最新，然后再提交改动到本地，最后进行推送。&quot;&gt;&lt;a href=&quot;#将代码提交到远程仓库中，其实通常只需要两条命令即可，首先是提交到本地，然后再将本地的记录推送到远端。但在实际工作中，为了防止本地仓库和远程仓库出现冲突，一般先让把远程代码同步到本地代码，让本地代码保持最新，然后再提交改动到本地，最后进行推送。&quot; class=&quot;headerlink&quot; title=&quot;将代码提交到远程仓库中，其实通常只需要两条命令即可，首先是提交到本地，然后再将本地的记录推送到远端。但在实际工作中，为了防止本地仓库和远程仓库出现冲突，一般先让把远程代码同步到本地代码，让本地代码保持最新，然后再提交改动到本地，最后进行推送。&quot;&gt;&lt;/a&gt;将代码提交到远程仓库中，其实通常只需要两条命令即可，首先是提交到本地，然后再将本地的记录推送到远端。但在实际工作中，为了防止本地仓库和远程仓库出现冲突，一般先让把远程代码同步到本地代码，让本地代码保持最新，然后再提交改动到本地，最后进行推送。&lt;/h6&gt;</summary>
    
    
    
    <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
    <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GIT篇---2.拉取远端代码以及配置ssh公钥（包含码云和github配置）（Windows系统）</title>
    <link href="http://yoursite.com/2020/08/31/git2/"/>
    <id>http://yoursite.com/2020/08/31/git2/</id>
    <published>2020-08-31T09:36:52.809Z</published>
    <updated>2020-08-31T10:59:55.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拉取远端代码：使用Git命令下载远程仓库到本地"><a href="#拉取远端代码：使用Git命令下载远程仓库到本地" class="headerlink" title="拉取远端代码：使用Git命令下载远程仓库到本地"></a>拉取远端代码：使用Git命令下载远程仓库到本地</h2><a id="more"></a><h3 id="1-创建远程代码仓库"><a href="#1-创建远程代码仓库" class="headerlink" title="1. 创建远程代码仓库"></a>1. 创建远程代码仓库</h3><h4 id="1-1-在github或者码云注册账号并且创建仓库（实例github）"><a href="#1-1-在github或者码云注册账号并且创建仓库（实例github）" class="headerlink" title="1.1 在github或者码云注册账号并且创建仓库（实例github）"></a>1.1 在github或者码云注册账号并且创建仓库（实例github）</h4><p>注册过程不再演示</p><h5 id="1-1-1-点击new即可"><a href="#1-1-1-点击new即可" class="headerlink" title="1.1.1 点击new即可"></a>1.1.1 点击new即可<img src="https://img-blog.csdnimg.cn/20200831165911624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></h5><h5 id="1-1-2-输入仓库名称及介绍点击确定即可"><a href="#1-1-2-输入仓库名称及介绍点击确定即可" class="headerlink" title="1.1.2 输入仓库名称及介绍点击确定即可"></a>1.1.2 输入仓库名称及介绍点击确定即可<img src="https://img-blog.csdnimg.cn/20200831170006169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></h5><p>创建好之后 复制地址<br><img src="https://img-blog.csdnimg.cn/20200831170411722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>建立远程仓库之后，默认里面有几个文件；接下来我们通过 git 的命令将远程仓库拉取到本地，一般会提供 HTTP 协议和 SSH 两种协议提供管理，两种协议所使用的鉴权方式不同，下面我们将两种方法都实践一次；</p><h3 id="2-HTTP-S-获取远程仓库"><a href="#2-HTTP-S-获取远程仓库" class="headerlink" title="2.  HTTP(S)获取远程仓库"></a>2.  HTTP(S)获取远程仓库</h3><h4 id="2-1-首次拉取"><a href="#2-1-首次拉取" class="headerlink" title="2.1 首次拉取"></a>2.1 首次拉取</h4><p>HTTP 协议首次拉取代码的命令格式如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 版本库地址    [本地文件夹名称]</span><br></pre></td></tr></table></figure><p>假设我需要把刚才新建的仓库代码拉取到本地,并且本地的文件夹名称叫gitText(也可以不指定本地文件夹名称，默认名字为远程仓库名字)，参考命令如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/highfish920/text-git.git gitText</span><br></pre></td></tr></table></figure><p>结果：<img src="https://img-blog.csdnimg.cn/20200831170810727.png#pic_center" alt="在这里插入图片描述"><br>这里警告是指克隆了一个空的存储库（因为新建的没有东西嘛）但是本地已经有了这个文件夹<br><img src="https://img-blog.csdnimg.cn/20200831170919893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>如果要求输入用户名密码才可以拉取的话输入用户名密码即可</p><h4 id="2-2-更新代码"><a href="#2-2-更新代码" class="headerlink" title="2.2 更新代码"></a>2.2 更新代码</h4><p>假设远程代码有变更，你想把本地代码更新时，可以在本地的版本库目录下通过git pull命令更新，不需要再指定远程地址，参考命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="2-3-临时记住密码"><a href="#2-3-临时记住密码" class="headerlink" title="2.3 临时记住密码"></a>2.3 临时记住密码</h4><p>如果你不想每次都输入 git 的认证信息，可以设置缓存认证数据，默认记住 15 分钟，如下命令所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config –-global credential.helper cache</span><br></pre></td></tr></table></figure><p>如果你想缓存更长时间，也可以指定缓存时长，比如下面是自定义配置记住 1 小时的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config credential.helper ‘cache –timeout=3600’</span><br></pre></td></tr></table></figure><h4 id="2-5-永久记住密码"><a href="#2-5-永久记住密码" class="headerlink" title="2.5 永久记住密码"></a>2.5 永久记住密码</h4><p>如果你不想每次提交代码都要输入用户名密码，也可以让 Git 永久记住密码，参考命令如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><p>命令执行完毕之后，会在当前用户主目录的.gitconfig文件中新增一项配置，配置如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[credential]</span><br><span class="line">    helper = store</span><br></pre></td></tr></table></figure><p>在上面的命令中，如果没有–global，则会在当前项目下的.git/config文件增加配置</p><p>从这里可以看出， git 永久记住密码其实是根据配置文件所决定，所以你也可以直接复制上面生成的配置到配置文件中。</p><h3 id="3-SSH拉取"><a href="#3-SSH拉取" class="headerlink" title="3.SSH拉取"></a>3.SSH拉取</h3><h4 id="3-1-1-拉取代码"><a href="#3-1-1-拉取代码" class="headerlink" title="3.1.1 拉取代码"></a>3.1.1 拉取代码</h4><p>现在我们再来看看SSH方式，相比HTTP(S)来说更加安全,因为SSH方式使用的是非对称加密，采用公钥与私钥的方式，不过相对来说配置起来会麻烦一些；好处是一次配置之后，后续不需要每次都进行认证，也更加安全。<br>ssh 方式首次拉取代码的命令没有什么变化，相比来说只是远程地址有变化，如下命令所示<br><img src="https://img-blog.csdnimg.cn/20200831171337935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:highfish920/text-git.git  git-text-ssh</span><br></pre></td></tr></table></figure><p>可以看到成功了<br><img src="https://img-blog.csdnimg.cn/20200831171505877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="3-1-2-创建一个ssh-key（github）"><a href="#3-1-2-创建一个ssh-key（github）" class="headerlink" title="3.1.2 创建一个ssh key（github）"></a>3.1.2 创建一个ssh key（github）</h4><p><strong>如果没有拉取成功的原因是没有配置公钥与私钥的话</strong><br>通过 ssh 协议拉取代码首先要保证当前用户的主目录存在一个.ssh的文件夹，并且里面已经存在私钥文件，如果没有的话我们可以通过<code>ssh-keygen</code>，生成一份公钥与私钥，如下命令所示<br>直接回车，输入y，接着回车<br><img src="https://img-blog.csdnimg.cn/20200831171900256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其中这两个地址分别保存了秘钥与公钥<br><img src="https://img-blog.csdnimg.cn/20200831172433386.png#pic_center" alt="在这里插入图片描述"><br>接下来复制公钥（重新生成之后会覆盖原先的公钥，需要github和码云重新配置）<br>打开github，点击头像下面的settings<br><img src="https://img-blog.csdnimg.cn/202008311727484.png#pic_center" alt="在这里插入图片描述"><br>然后点击SSH那个，点击new GPG key 粘贴公钥即可，其中的Title随便写（这里原先配置过，所以有一个）<br><img src="https://img-blog.csdnimg.cn/20200831172955638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>配置成功后在尝试拉取代码即可</p><h4 id="3-1-3-创建一个ssh-key（码云）"><a href="#3-1-3-创建一个ssh-key（码云）" class="headerlink" title="3.1.3 创建一个ssh key（码云）"></a>3.1.3 创建一个ssh key（码云）</h4><p>当确认公钥和私钥生成完毕之后，我们还需要将公钥放到远程的 git 仓库中去，在码云的版本库中，个人设置》安全》ssh公钥，在管理页面的左侧菜单中有一个添加公钥的选项，我们将上面的公钥内容复制进去即可</p><h4 id="3-1-4-更新代码"><a href="#3-1-4-更新代码" class="headerlink" title="3.1.4 更新代码"></a>3.1.4 更新代码</h4><p>ssh 方式更新代码命令和上面的 http 方式拉取代码命令一致，同样需要在 git-text-ssh目录下执行命令：git pull，然后可以看到git成功的拉取到了代码<br>本文整理自 <a href="http://www.imooc.com/read/51">http://www.imooc.com/read/51</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;拉取远端代码：使用Git命令下载远程仓库到本地&quot;&gt;&lt;a href=&quot;#拉取远端代码：使用Git命令下载远程仓库到本地&quot; class=&quot;headerlink&quot; title=&quot;拉取远端代码：使用Git命令下载远程仓库到本地&quot;&gt;&lt;/a&gt;拉取远端代码：使用Git命令下载远程仓库到本地&lt;/h2&gt;</summary>
    
    
    
    <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
    <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GIT篇---1.安装GIt以及GIT基本认识和配置(Windows系统)</title>
    <link href="http://yoursite.com/2020/08/31/git1/"/>
    <id>http://yoursite.com/2020/08/31/git1/</id>
    <published>2020-08-31T08:52:21.972Z</published>
    <updated>2020-08-31T10:17:16.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装-Git"><a href="#1-安装-Git" class="headerlink" title="1. 安装 Git"></a>1. 安装 Git</h2><a id="more"></a><p>在 Windows 系统中安装Git非常简单，只需要下载Git的安装包，然后安装引导点击安装即可：</p><p>Git下载地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a><br>下载完安装包之后，双击 EXE 安装包，一直点击Next安装即可在安装完成之后，会在你的右键菜单栏中增加一个Git的选项，你可以在电脑桌面点击鼠标右键，会看到多出两个菜单，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200831162657644.png#pic_center" alt="在这里插入图片描述"><br>当你点击Git bash Here菜单之后，可以看到一个终端窗口，在终端里面输入命令git –version，如果可以看到 git 的版本信息，则说明安装成功，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200831165049265.png#pic_center" alt="在这里插入图片描述"></p><h2 id="2-本地创建一个-Git-仓库"><a href="#2-本地创建一个-Git-仓库" class="headerlink" title="2.本地创建一个 Git 仓库"></a>2.本地创建一个 Git 仓库</h2><ol><li>创建本地文件夹text</li><li>进入本地文件夹目录终端输入 <code>git init</code> 初始化仓库，初始化后，会发现文件夹里面多出了一个.git的文件<br><img src="https://img-blog.csdnimg.cn/20200831163313603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li><li>简单认识.git</li></ol><p><img src="https://img-blog.csdnimg.cn/20200831163522222.png#pic_center" alt="在这里插入图片描述"></p><ul><li>hooks 目录包含客户端或服务端的钩子脚本</li><li>objects 目录存储所有数据内容</li><li>info 目录包含一个全局性排除文件</li><li>refs 目录存储分支的提交对象的指针</li><li>description用来显示对仓库的描述信息</li><li>HEAD 文件指示目前被检出的分支</li><li>config 文件包含项目特有的配置选项</li></ul><ol start="4"><li>查看配置信息<br>在设置昵称和邮箱之前，可以先检查一下之前有没有配置过昵称和邮箱<br>查看昵称的命令如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure><p>查看邮箱的命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200831163906797.png#pic_center" alt="在这里插入图片描述"></p><p>4.1 设置配置信息<br>如果执行上面的命令没有返回相应的昵称和邮箱，说明你还没有配置昵称和邮箱。那么就需要进行配置<br>配置昵称的命令参考如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的昵称&quot;</span></span><br></pre></td></tr></table></figure><p>配置邮箱的命令参考如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>4.2 修改配置信息<br>在配置中如果不小心配置错了，或者后面想修改配置的时候，是不能通过重复执行上面的设置昵称命令，来修改昵称的，邮箱修改同理。如果你多次设置昵称，它会在命令执行后提示你无法重复配置或者可能不给你提示，但是这种情况会导致一个 key 配置了多个 value 的问题。</p><p><strong>介绍两种方法， 第一种是通过命令行，第二种是通过修改配置文件。</strong></p><p>4.2.1 <strong>命令行修改配置</strong></p><p>通过命令行修改的方式比较简单，直接执行以下的命令即可<br>修改昵称参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --replace-all user.name <span class="string">&quot;your user name&quot;</span></span><br></pre></td></tr></table></figure><p>修改邮箱地址参考命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --replace-all user.email<span class="string">&quot;your user email&quot;</span></span><br></pre></td></tr></table></figure><p>4.2.2 <strong>修改配置文件</strong></p><p>Windows 系统位于用户主目录下，假设你当前的用户是administrator，那么对应的配置文件的路径应该是 C:\Users\administrator.gitconfig，可以直接使用记事本修改里边的 name 或者 email。</p><p>如果之前已经配置过昵称和邮箱的情况下，当使用记事本打开配置文件之后，可以看到如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">        name = daxia</span><br><span class="line">        email = 78778443@qq.com</span><br></pre></td></tr></table></figure><p>在如果有重复的 name 或 email，可以将其删掉，只剩下一个就好。修改完，通过 git bash 输入 git config –list可以查看是否修改成功了。<br>本文整理自 <a href="http://www.imooc.com/read/51">http://www.imooc.com/read/51</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-安装-Git&quot;&gt;&lt;a href=&quot;#1-安装-Git&quot; class=&quot;headerlink&quot; title=&quot;1. 安装 Git&quot;&gt;&lt;/a&gt;1. 安装 Git&lt;/h2&gt;</summary>
    
    
    
    <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
    <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>单页面应用有什么SEO方案</title>
    <link href="http://yoursite.com/2020/08/30/seo/"/>
    <id>http://yoursite.com/2020/08/30/seo/</id>
    <published>2020-08-30T08:44:02.195Z</published>
    <updated>2020-08-30T08:44:34.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单页面应用有什么SEO方案"><a href="#单页面应用有什么SEO方案" class="headerlink" title="单页面应用有什么SEO方案"></a>单页面应用有什么SEO方案</h2><a id="more"></a><p>1    前端要采用history模式（HTML5 History API），一般用来写单页应用的框架都有这个模式。<br>2    要用后端做一套页面，内容和对应的前端页面一模一样，即所谓静态化，我用的sails框架即可实现这一点，主流的如Node.js的express框架也可以，php应该也行。<br>3    必须用nginx做代理跳转，将搜索引擎识别出后流量引到后端的端口上，看到预先渲染给搜索引擎看的页面，还有history模式自带的404问题也需要在nginx里将404转index.html或者rewrite才可以<br><strong>原因：</strong> 较之于传统页面，单页应用需要先下载框架（数据 / 模板），然后才能开始加载数据<br>方案：<br>1    服务器端渲染首屏（SSR基于vue的服务端下载）<br>2    让服务端把首屏的数据渲染在页面上<br>3    进行基本的css 模板 js的编译合并<br>4    减少请求次数，使用gulp工具，把 css 打包成一个文件, js打包成一个文件, 模板打包成一个js文件($templateCache) 可以和js 文件打包成一起（促使模板JS文件和JS文件一次性请求）<br>5    代码分块，如果首屏不需要的块，就不用加载了<br>6    路由组件懒加载。当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样更加高效。<br>7    如果有大量图片使用懒加载</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;单页面应用有什么SEO方案&quot;&gt;&lt;a href=&quot;#单页面应用有什么SEO方案&quot; class=&quot;headerlink&quot; title=&quot;单页面应用有什么SEO方案&quot;&gt;&lt;/a&gt;单页面应用有什么SEO方案&lt;/h2&gt;</summary>
    
    
    
    <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="SEO" scheme="http://yoursite.com/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>如何优化dom操作的性能</title>
    <link href="http://yoursite.com/2020/08/30/dom%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/08/30/dom%E4%BC%98%E5%8C%96/</id>
    <published>2020-08-30T08:40:21.977Z</published>
    <updated>2020-08-30T08:43:58.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何优化dom操作的性能"><a href="#如何优化dom操作的性能" class="headerlink" title="如何优化dom操作的性能"></a>如何优化dom操作的性能</h2><a id="more"></a><p>1    查找元素的优化。因为ID是唯一的，也有原始的方法，因此使用ID查找元素是最快的，其次的是根据类和类型查找元素，通过属性查找元素是最慢的，因此应该尽可能的通过ID或者类来查找元素，避免通过属性来查找元素<br>2    减少访问和改变DOM元素，包括添加，修改，删除DOM<br>  改变DOM就会引起浏览器渲染，而渲染是相当慢的，因此应该避免不必要的渲染</p><p>3    减少改变DOM的样式类等<br> 改变DOM元素的样式，类也会导致浏览器渲染，因此也应该减少不必要的操作<br>4    批量修改DOM时从文档流中摘除该元素 ，对其应用多重改变 ，将元素带回文档中 ， 这样可以最小化重绘和重排版 。<br>具体方法: 1 隐藏元素，进行修改，然后再显示它。 2将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素。<br>5    减少iframe    iframe需要消耗大量的时间，并阻塞下载，建议少用<br>6    样式放在header中，脚本放在关闭标签</body>之前样式放在header中，可以加快渲染，脚本放在关闭标签</body>之前可以加快下载速度，不免阻塞下载。<br>7    使用事件委托，减少绑定事件的数量<br>8    多次访问同一DOM，应该用局部变量缓存该DOM</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;如何优化dom操作的性能&quot;&gt;&lt;a href=&quot;#如何优化dom操作的性能&quot; class=&quot;headerlink&quot; title=&quot;如何优化dom操作的性能&quot;&gt;&lt;/a&gt;如何优化dom操作的性能&lt;/h2&gt;</summary>
    
    
    
    <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="dom" scheme="http://yoursite.com/tags/dom/"/>
    
  </entry>
  
  <entry>
    <title>CDN的用法，CDN</title>
    <link href="http://yoursite.com/2020/08/30/cdn/"/>
    <id>http://yoursite.com/2020/08/30/cdn/</id>
    <published>2020-08-30T08:39:15.088Z</published>
    <updated>2020-08-30T08:40:12.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><a id="more"></a><p>CDN即内容分发网络。CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求<br>CDN的使用，以腾讯CDN为例：<br>1    登录腾讯云CDN，选择“接入管理”，点击“添加域名”添加我们需要加速的域。<br>2    进入“添加域名”界面，在域名那里填好你要加速的域名。源站IP那里可以填自己服务器的IP。如果你用的是虚拟主机，可以填空间商给你的域名。配置完成后点下一步！<br>3    进入“基本配置”界面，填写相关要求，在缓存时间那里，腾讯CDN默认的是将你所有的文件缓存30天，你可以根据自身情况修改天数。填写好后点击下一步。<br>4    下一步也差不多，填写相关要求，没问题点击提交就好。</p><p>CDN的适用场景：<br>解决因分布、带宽、服务器性能带来的访问延迟问题,适用于网站站点/应用加速、点播、直播、视音频点播、大文件下载分发加速、移动应用加速等场景</p><h2 id="CDN的用法"><a href="#CDN的用法" class="headerlink" title="CDN的用法"></a>CDN的用法</h2><p>1    把css放在head中加载，这个能让页面更早的开始渲染。避免把css放在页面尾部，否则可能会出现闪屏，如果css加载的很慢，DOM结构先出来，css后出来，然后页面样式突然发生变化，就造成了闪屏。<br>2    把js放在body末尾加载，因为js它本身会阻塞HTML的解析以及css的渲染。<br>3    不要使用css的表达式，css的表达式一方面是兼容性问题，虽然看起来比较强大，但是实际性能开销很大，因为它实际的执行频率是远远超出预期的，如果使用了css的表达式，可能导致页面卡顿。</p><p>4    用外链的方式引用css和js，可以有效的减少HTML的体积，并且外链了之后，css和js作为静态资源可以给他设置合适的缓存的响应头；能够合理的利用浏览器的缓存。<br>5    压缩js和css，在生产环境里面删除这一类文件不必要的注释、空白，并且对js进行变量名压缩，混淆压缩，对css进行属性的合并，然后进行选择符的合并。<br>6    不重复加载js，因为在IE里面，还是会有多个请求，不能发挥缓存优势，并且你重复加载js，意味着要更长的js执行时间。<br>7    让Ajax请求可缓存，GZIP、内容压缩都可以适用。<br>8    用GET方式发起Ajax请求，因为GET方式可以缓存，如果是获取信息的，那么GET方式是更语义化的。<br>9    组件延迟加载，保障页面关键的静态资源优先加载，因为并发数限制，还有一些延迟加载的典型手段叫做“lazyload”。<br>10    减少DOM节点数，DOM节点这个规则是非常容易理解，就是如果你的DOM结构非常的复杂，那么浏览器在解析的时候，进行布局、渲染时计算量更大，那么少一点的话，浏览器的开销会少一些，渲染布局的速度就会快一些。<br>11    避免在页面中使用frame类（包括iframe和frameset），因为iframe它会阻塞父文档的onload，即使它是一个空白的也会比较耗时。<br>12    要减少COOKIE的体积，因为COOKIE在每一次请求，就是跟主文档相关的，只要是同域的，COOKIE的全部内容都可以带上。<br>13    使用无cookie域名加载静态资源，可以减少静态资源加载时的网络传输量，静态资源加载通常是不需要cookie的。<br>14    减少js中的DOM访问，还有对于你查找到的元素，缓存在js的变量中，后面就不需要在去查找DOM树了，还有节点增加是合理利用DocumentFragment，然后在把DocumentFragment放在实际的DOM树里面，然后还有一个是不要用js去频繁修改样式。<br>15    使用更多的事件监听机制，基于事件冒泡的委托机制，你可以有效减少绑定的数量。<br>16    使用常见的图片优化手段，对于代码来说，图片的体积很大，常用的图片压缩工具有“PNGCrush”“JPEGTRAN”“PNGQUANT”。<br>17    不要在HTML中缩放图片，你实际上在页面上用到多大图片，那你就提供适当尺寸即可，不然它只会徒增渲染的开销。<br>18    不要把图片SRC置空，因为在主文档的浏览器里面都会引发额外的请求。<br>19    任何资源尽量在25k以内，因为iPhone无法缓存25k以上的资源。<br>20    预渲染，预渲染比预下载更进一步，不仅仅下载页面，而且还会预先将它渲染出来，目前在Chrome（9.0.597.0）中有实现，不过需要在about:flags中将’Web Page Prerendering’开启。<br>21    DNS优化；CDN优化；http优化；减少域名解析时间；增多域名提高并发</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;CDN&quot;&gt;&lt;a href=&quot;#CDN&quot; class=&quot;headerlink&quot; title=&quot;CDN&quot;&gt;&lt;/a&gt;CDN&lt;/h2&gt;</summary>
    
    
    
    <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="CDN" scheme="http://yoursite.com/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>基本数据结构：（数组、 对列、 链表、堆、二叉树、嘻哈表等等），8种排序算法，原理，以及适用的场景和复杂度，费波拉切数列的实现方法</title>
    <link href="http://yoursite.com/2020/08/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/08/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-08-30T08:35:33.303Z</published>
    <updated>2020-08-30T08:35:46.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组：数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。（如图所示）"><a href="#数组：数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。（如图所示）" class="headerlink" title="数组：数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。（如图所示）"></a>数组：数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。（如图所示）</h2><a id="more"></a><p> <img src="https://img-blog.csdnimg.cn/20200830163134546.png#pic_center" alt="在这里插入图片描述"></p><p>链表：存储的数据在地址空间上可连续，可不连续，链表中的每一个节点都包括数据和指向下一个地址的指针，查找数据的时间复杂度为O(n)，方便数据的增删。<br> <img src="https://img-blog.csdnimg.cn/20200830163128881.png#pic_center" alt="在这里插入图片描述"></p><p>栈：栈是一种先入后出的逻辑结构，每次加入新的元素和拿走元素都在顶部操作。<br> <img src="https://img-blog.csdnimg.cn/20200830163122153.png#pic_center" alt="在这里插入图片描述"></p><p>对列：是一种先入后出的逻辑结构，对于元素的操作分别在队头和队尾，元素的插入在队尾，元素的删除在队头。<br> <img src="https://img-blog.csdnimg.cn/2020083016311541.png#pic_center" alt="在这里插入图片描述"></p><p>二叉树：每个节点至多只有两个子树的结构，在父节点中有指向左右子树的指针。<br>二叉树的 先序遍历：根–左–右。中序遍历：左–根–右。后序遍历：左–右–根。<br>查找二叉树：左子树的值小于根节点的值，右子树的值大于根节点的值，在插入数据时，从根节点开始往下比较，小于比较值则放在左边，大于比较值放在右边。插入一个值的时间复杂度是O(logn)。<br>平衡二叉树：左右子树的高度差的绝对值不超过1。<br> <img src="https://img-blog.csdnimg.cn/20200830163108278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="8种排序算法，原理，以及适用的场景和复杂度"><a href="#8种排序算法，原理，以及适用的场景和复杂度" class="headerlink" title="8种排序算法，原理，以及适用的场景和复杂度"></a>8种排序算法，原理，以及适用的场景和复杂度</h2><p><img src="https://img-blog.csdnimg.cn/20200830163305556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里就体现2个常问的问题：冒泡排序的原理：<br>S1：从待排序序列的起始位置开始，从前往后依次比较各个位置和其后一位置的大小并执行S2。<br>S2：如果当前位置的值大于其后一位置的值，就把他俩的值交换（完成一次全序列比较后，序列最后位置的值即此序列最大值，所以其不需要再参与冒泡）。<br>S3：将序列的最后位置从待排序序列中移除。若移除后的待排序序列不为空则继续执行S1，否则冒泡结束。<br>在举个栗子<br><img src="https://img-blog.csdnimg.cn/20200830163319253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>快速排序：快速排序是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此实现整个数据变成有序序列<br>在举个栗子：<br><img src="https://img-blog.csdnimg.cn/20200830163333141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="费波拉切数列的实现方法"><a href="#费波拉切数列的实现方法" class="headerlink" title="费波拉切数列的实现方法"></a>费波拉切数列的实现方法</h2><p><img src="https://img-blog.csdnimg.cn/20200830163357899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数组：数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。（如图所示）&quot;&gt;&lt;a href=&quot;#数组：数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。（如图所示）&quot; class=&quot;headerlink&quot; title=&quot;数组：数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。（如图所示）&quot;&gt;&lt;/a&gt;数组：数组是最最基本的数据结构，很多语言都内置支持数组。数组是使用一块连续的内存空间保存数据，保存的数据的个数在分配内存的时候就是确定的。（如图所示）&lt;/h2&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Vue，Angular，jquery--使用框架，zepto和jquery是什么关系，jquery源码如何实现选择器，为什么$取得的对象要设计成数组的形式，jquery如何绑定事件，有几种类型和区别，MVVM,MVC,MVP，Vue和Angular的双向数据绑定原理，Vue和Angular的组件通信以及路由原理？Vue和Angular的组件通信以及路由原理？</title>
    <link href="http://yoursite.com/2020/08/29/%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/08/29/%E6%A1%86%E6%9E%B6/</id>
    <published>2020-08-29T08:54:40.397Z</published>
    <updated>2020-08-30T08:35:29.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用框架"><a href="#使用框架" class="headerlink" title="使用框架"></a>使用框架</h2><a id="more"></a><p>UI框架    bootstrap、Mui、layui<br>js框架    vue、angular、react</p><h2 id="zepto和jquery是什么关系"><a href="#zepto和jquery是什么关系" class="headerlink" title="zepto和jquery是什么关系"></a>zepto和jquery是什么关系</h2><p>二者都是js库，zepto是jQuery的轻量级替代品，它与jquery有着类似的api，zepto主要是用在移动端，不支持IE浏览器，jquery主要用在PC端，jQuery 版本 2 以上不支持 IE6，7，8 浏览器</p><h2 id="jquery源码如何实现选择器，为什么-取得的对象要设计成数组的形式"><a href="#jquery源码如何实现选择器，为什么-取得的对象要设计成数组的形式" class="headerlink" title="jquery源码如何实现选择器，为什么$取得的对象要设计成数组的形式"></a>jquery源码如何实现选择器，为什么$取得的对象要设计成数组的形式</h2><p>jquery内部采用了一种“类数组对象”的方式作为存储结构，既可以像对象一样处理jQuery操作，也可以像数组一样使用push、pop、shift、sort、each、map等类数组的方法操作jquery</p><h2 id="jquery如何绑定事件，有几种类型和区别"><a href="#jquery如何绑定事件，有几种类型和区别" class="headerlink" title="jquery如何绑定事件，有几种类型和区别"></a>jquery如何绑定事件，有几种类型和区别</h2><p>jquery绑定事件的方法分别是：bind(),live(),delegate()和on()，<br>像bind(),live(),delegate(),随着jquery版本的更新，已经被移除，注意：bind()是在3.0版本之后被移除的，现在用的最多的是on()，on()既可以绑定单事件，也可以绑定多事件，还可以进行事件委托<br>区别就是：bind()的事件绑定是只对当前页面选中的元素有效，对动态创建的元素bind()事件，是没有办法达到效果的，而其余三个可以</p><h2 id="MVVM-MVC-MVP"><a href="#MVVM-MVC-MVP" class="headerlink" title="MVVM,MVC,MVP"></a>MVVM,MVC,MVP</h2><p>MVC：先介绍M:Model(模型)，V:View(视图) ，C：Controller（控制器),View层是展示html页面的，Controller层是业务逻辑，Model层是数据保存，视图的改变会通过控制器要求数据层改变状态，然后反馈给视图层。<br>MVVM：是将Controller改为VM，是Model-View-ViewModel的缩写，视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。<br>MVP：MVP模式是将Controller改为Presenter，View和Model之间不发生联系，都通过Presenter传递，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller</p><h2 id="Vue和Angular的双向数据绑定原理"><a href="#Vue和Angular的双向数据绑定原理" class="headerlink" title="Vue和Angular的双向数据绑定原理"></a>Vue和Angular的双向数据绑定原理</h2><p>Vue 双向数据绑定的原理：<br>vue将普通的对象的属性通过Object.defineProperty转换为ES5特性之一的 getter/setter，模板中每个指令/数据绑定都有一个对应的 watcher 对象, 当修改对象值的时，首先会触发属性的setter，在setter被调用时，会触发 watcher 重新计算 ，也就会导致它的关联指令更新 DOM<br><img src="https://img-blog.csdnimg.cn/2020082916492742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>Angular双向数据绑定的原理：<br>angular.js是通过脏值监测的方式查看数据是否变更，最简单的方法是通过setInterval()定时循环检测数据变动</p><h2 id="Vue和Angular的组件通信以及路由原理？"><a href="#Vue和Angular的组件通信以及路由原理？" class="headerlink" title="Vue和Angular的组件通信以及路由原理？"></a>Vue和Angular的组件通信以及路由原理？</h2><p>vue得组件通信，</p><ol><li>父组件传递数据给子组件<br>举个栗子<br><img src="https://img-blog.csdnimg.cn/20200829165250837.png#pic_center" alt="在这里插入图片描述"></li></ol><p>子组件通过props来接收数据:<br>方式1：<br>props: [‘childMsg’]<br>子组件与父组件通信</p><p>  <img src="https://img-blog.csdnimg.cn/20200829165259558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200829165305575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020082916531122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>Angular组件间通信<br>  Angular组件之间的通信方式分为三种：<br>1）    父组件向子组件通信（输入属性）分为两步：<br>        1、在子组件上定义自己要接受父组件输入的参数：<br>        <img src="https://img-blog.csdnimg.cn/20200829165325179.png#pic_center" alt="在这里插入图片描述"></p><pre><code>             2、在父组件的HTML模板中声明要输入的数据：             ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200829165340141.png#pic_center)    子</code></pre><p>2）    子组件向父组件通信（输出属性）<br>          1、在子组件中设置要输出的类型：<br>          <img src="https://img-blog.csdnimg.cn/20200829165346505.png#pic_center" alt="在这里插入图片描述"></p><pre><code>        2、在html模板中设置事件：    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200829165403486.png#pic_center)</code></pre><p>3、 在父组件的控制器中接收输出属性<br> <img src="https://img-blog.csdnimg.cn/20200829165408915.png#pic_center" alt="在这里插入图片描述"></p><pre><code> 3) 使用中间人模式通信        所谓中间人模式就是：当A =》 C 通信时，先将A =》B，B=》C,         B就是所谓中间人模式；         按照情况一般分为两种：         1、兄弟组件通信            这里我们选择父组件做为中间人，先是使用输出属性，再使用输入属性就OK了         2、非兄弟组件通信            选择一个依赖注入service做为中间人，然后进行通信。</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;使用框架&quot;&gt;&lt;a href=&quot;#使用框架&quot; class=&quot;headerlink&quot; title=&quot;使用框架&quot;&gt;&lt;/a&gt;使用框架&lt;/h2&gt;</summary>
    
    
    
    <category term="框架-类库" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6-%E7%B1%BB%E5%BA%93/"/>
    
    
    <category term="框架-类库" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6-%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>java之-深拷贝、浅拷贝</title>
    <link href="http://yoursite.com/2020/08/28/java-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/08/28/java-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-08-28T09:32:33.389Z</published>
    <updated>2020-08-28T09:33:51.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java之-深拷贝、浅拷贝"><a href="#java之-深拷贝、浅拷贝" class="headerlink" title="java之-深拷贝、浅拷贝"></a>java之-深拷贝、浅拷贝</h2><a id="more"></a><p>文章转载自CodeSheep羊叔<br><a href="https://github.com/hansonwang99/JavaCollection">https://github.com/hansonwang99/JavaCollection</a></p><p>为了便于下文的讲述和举例，我们这里先定义两个类：Student和Major，分别表示「学生」以及「所学的专业」，二者是包含关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生的所学专业</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Major</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String majorName; <span class="comment">// 专业名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> majorId;     <span class="comment">// 专业代号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;      <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Major major;  <span class="comment">// 所学专业</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200828172327769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>赋值 vs 浅拷贝 vs 深拷贝</p><p>对象赋值<br>赋值是日常编程过程中最常见的操作，最简单的比如：<br>Student codeSheep = new Student();<br>Student codePig = codeSheep;<br>严格来说，这种不能算是对象拷贝，因为拷贝的仅仅只是引用关系，并没有生成新的实际对象：<br><img src="https://img-blog.csdnimg.cn/2020082817233960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>浅拷贝<br>浅拷贝属于对象克隆方式的一种，重要的特性体现在这个 「浅」 字上。<br>比如我们试图通过studen1实例，拷贝得到student2，如果是浅拷贝这种方式，大致模型可以示意成如下所示的样子：<br><img src="https://img-blog.csdnimg.cn/20200828172351451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>很明显，值类型的字段会复制一份，而引用类型的字段拷贝的仅仅是引用地址，而该引用地址指向的实际对象空间其实只有一份。<br>一图胜前言，我想上面这个图已经表现得很清楚了。<br>深拷贝<br>深拷贝相较于上面所示的浅拷贝，除了值类型字段会复制一份，引用类型字段所指向的对象，会在内存中也创建一个副本，就像这个样子：<br><img src="https://img-blog.csdnimg.cn/2020082817242772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>原理很清楚明了，下面来看看具体的代码实现吧。<br>浅拷贝代码实现</p><p>还以上文的例子来讲，我想通过student1拷贝得到student2，浅拷贝的典型实现方式是：让被复制对象的类实现Cloneable接口，并重写clone()方法即可。<br>以上面的Student类拷贝为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;      <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Major major;  <span class="comment">// 所学专业</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们写个测试代码，一试便知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Major m = <span class="keyword">new</span> Major(<span class="string">&quot;计算机科学与技术&quot;</span>,<span class="number">666666</span>);</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student( <span class="string">&quot;CodeSheep&quot;</span>, <span class="number">18</span>, m );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 由 student1 拷贝得到 student2</span></span><br><span class="line">        Student student2 = (Student) student1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println( student1 == student2 );</span><br><span class="line">        System.out.println( student1 );</span><br><span class="line">        System.out.println( student2 );</span><br><span class="line">        System.out.println( <span class="string">&quot;\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改student1的值类型字段</span></span><br><span class="line">        student1.setAge( <span class="number">35</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 修改student1的引用类型字段</span></span><br><span class="line">        m.setMajorName( <span class="string">&quot;电子信息工程&quot;</span> );</span><br><span class="line">        m.setMajorId( <span class="number">888888</span> );</span><br><span class="line"></span><br><span class="line">        System.out.println( student1 );</span><br><span class="line">        System.out.println( student2 );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行得到如下结果：<br><img src="https://img-blog.csdnimg.cn/20200828172454426.png#pic_center" alt="在这里插入图片描述"></p><p>从结果可以看出：<br>student1==student2打印false，说明clone()方法的确克隆出了一个新对象；<br>修改值类型字段并不影响克隆出来的新对象，符合预期；<br>而修改了student1内部的引用对象，克隆对象student2也受到了波及，说明内部还是关联在一起的<br>深拷贝代码实现</p><p>深度遍历式拷贝<br>虽然clone()方法可以完成对象的拷贝工作，但是注意：clone()方法默认是浅拷贝行为，就像上面的例子一样。若想实现深拷贝需覆写 clone()方法实现引用对象的深度遍历式拷贝，进行地毯式搜索。<br>所以对于上面的例子，如果想实现深拷贝，首先需要对更深一层次的引用类Major做改造，让其也实现Cloneable接口并重写clone()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Major</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次我们还需要在顶层的调用类中重写clone方法，来调用引用类型字段的clone()方法实现深度拷贝，对应到本文那就是Student类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        student.major = (Major) major.clone(); <span class="comment">// 重要！！！</span></span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候上面的测试用例不变，运行可得结果：<br><img src="https://img-blog.csdnimg.cn/20200828172513124.png#pic_center" alt="在这里插入图片描述"></p><p>很明显，这时候student1和student2两个对象就完全独立了，不受互相的干扰。<br>利用反序列化实现深拷贝<br>记得在前文《序列化/反序列化，我忍你很久了》中就已经详细梳理和总结了「序列化和反序列化」这个知识点了。<br>利用反序列化技术，我们也可以从一个对象深拷贝出另一个复制对象，而且这货在解决多层套娃式的深拷贝问题时效果出奇的好。<br>所以我们这里改造一下Student类，让其clone()方法通过序列化和反序列化的方式来生成一个原对象的深拷贝副本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;      <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Major major;  <span class="comment">// 所学专业</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将对象本身序列化到字节流</span></span><br><span class="line">            ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream objectOutputStream =</span><br><span class="line">                    <span class="keyword">new</span> ObjectOutputStream( byteArrayOutputStream );</span><br><span class="line">            objectOutputStream.writeObject( <span class="keyword">this</span> );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再将字节流通过反序列化方式得到对象副本</span></span><br><span class="line">            ObjectInputStream objectInputStream =</span><br><span class="line">                    <span class="keyword">new</span> ObjectInputStream( <span class="keyword">new</span> ByteArrayInputStream( byteArrayOutputStream.toByteArray() ) );</span><br><span class="line">            <span class="keyword">return</span> (Student) objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这种情况下要求被引用的子类（比如这里的Major类）也必须是可以序列化的，即实现了Serializable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Major</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... 其他省略 ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候测试用例完全不变，直接运行，也可以得到如下结果：</p><p>很明显，这时候student1和student2两个对象也是完全独立的，不受互相的干扰，深拷贝完成。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;java之-深拷贝、浅拷贝&quot;&gt;&lt;a href=&quot;#java之-深拷贝、浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;java之-深拷贝、浅拷贝&quot;&gt;&lt;/a&gt;java之-深拷贝、浅拷贝&lt;/h2&gt;</summary>
    
    
    
    <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
    <category term="java拷贝" scheme="http://yoursite.com/tags/java%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>对AMD,CMD,CommonJs的理解</title>
    <link href="http://yoursite.com/2020/08/28/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2020/08/28/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9B%B8%E5%85%B3/</id>
    <published>2020-08-28T09:00:02.355Z</published>
    <updated>2020-08-28T09:01:47.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对AMD-CMD-CommonJs的理解"><a href="#对AMD-CMD-CommonJs的理解" class="headerlink" title="对AMD,CMD,CommonJs的理解"></a>对AMD,CMD,CommonJs的理解</h2><a id="more"></a><p><code>AMD</code>规范即异步模块加载机制。从规范描述页面看，<code>AMD</code>很短也很简单，但却完整描述了模块的定义，依赖关系，引用关系以及加载机制。 AMD规范其实只有一个主要接口 <code>define(id,dependencies,factory)</code>，它要在声明模块的时候指定所有的依赖<code>dependencies</code>，并且还要当做形参传到<code>factory</code>中，对于依赖的模块提前执行，依赖前置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>       define(<span class="string">&quot;module&quot;</span>, [<span class="string">&quot;dep1&quot;</span>, <span class="string">&quot;dep2&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;  </span><br><span class="line"><span class="number">2.</span>      <span class="keyword">return</span> someExportedValue;  </span><br><span class="line"><span class="number">3.</span>    &#125;);  </span><br><span class="line"><span class="number">4.</span>    <span class="built_in">require</span>([<span class="string">&quot;module&quot;</span>, <span class="string">&quot;../file&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);  </span><br></pre></td></tr></table></figure><p><strong>优点</strong>：1、适合在浏览器环境异步加载2、并行加载多个模块<br><strong>缺点</strong>：1、提高开发成本，代码阅读和书写比较困难2、不符合通用的模块思维方式，是一种妥协的实现<br>实现：<code>requireJS，NodeJs，Dojo，JQuery</code><br>CMD规范和AMD相似，尽量保持简单，并且与<code>CommonJS</code>和<code>NodeJS</code>的<code>Modules</code>规范保持了很大的兼容性。在CMD中，一个模块就是一个文件，格式为：<code>define( factory )</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6.</span>    define(<span class="string">&quot;module&quot;</span>, [<span class="string">&quot;dep1&quot;</span>, <span class="string">&quot;dep2&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;  </span><br><span class="line"><span class="number">7.</span>      <span class="keyword">return</span> someExportedValue;  </span><br><span class="line"><span class="number">8.</span>    &#125;);  </span><br><span class="line"><span class="number">9.</span>    <span class="built_in">require</span>([<span class="string">&quot;module&quot;</span>, <span class="string">&quot;../file&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;); </span><br></pre></td></tr></table></figure><p><strong>优点</strong>：1、依赖就近，延迟执行2、很容易在node中运行<br><strong>缺点</strong>：1、依赖SPM打包，模块的加载逻辑偏重<br><strong>实现：SeaJS</strong><br><code>CommonJS</code>是在浏览器环境之外构建<code>JavaScript</code>生态系统为目标产生的项目，比如服务器和桌面环境中。<code>CommonJS</code>规范是为了解决<code>JavaScript</code>的作用域问题而定义的模块形式，可以使每个模块在它自身的命名空间中执行。该规范的主要内容是：模块必须通过  <code>module.exports</code>导出对外的变量或接口，通过<code>require()</code>来导入其他模块的输出到当前模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.</span>    <span class="comment">// moduleA.js  </span></span><br><span class="line"><span class="number">11.</span>    <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>)</span>&#123;  </span><br><span class="line"><span class="number">12.</span>        <span class="keyword">return</span> value * <span class="number">2</span>;  </span><br><span class="line"><span class="number">13.</span>    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="number">14.</span>    <span class="comment">// moduleB.js  </span></span><br><span class="line"><span class="number">15.</span>    <span class="keyword">var</span> multiplyBy2 = <span class="built_in">require</span>(<span class="string">&#x27;./moduleA&#x27;</span>);  </span><br><span class="line"><span class="number">16.</span>    <span class="keyword">var</span> result = multiplyBy2(<span class="number">4</span>);  </span><br></pre></td></tr></table></figure><p><code>CommonJS</code>是同步加载模块，一个单独的文件就是一个模块。但其实也有浏览器端的实现，其原理是将所有模块都定义好并通过id进行索引，这样就可以浏览器进行解析了 服务器端的<code>Node.js</code>遵循<code>CommonJS</code>规范。核心思想是允许模块通过<code>require</code> 方法来同步加载所要依赖的其他模块，然后通过 <code>exports</code>或<code>module.exports</code>来导出需要暴露的接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17.</span>    <span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>);  </span><br><span class="line"><span class="number">18.</span>    <span class="built_in">require</span>(<span class="string">&quot;../file.js&quot;</span>);  </span><br><span class="line"><span class="number">19.</span>    <span class="built_in">exports</span>.doStuff = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;  </span><br><span class="line"><span class="number">20.</span>    <span class="built_in">module</span>.exports = someValue;  </span><br></pre></td></tr></table></figure><p><strong>优点</strong>：1、服务器端便于重用2、NPM中已经将近20w个模块包3、简单并容易使用<br><strong>缺点</strong>：1、同步的模块方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的2、不能非阻塞的并行加载多个模块<br><strong>区别：（AMD  or  CMD）</strong><br>1    对于依赖的模块，<code>AMD</code> 是提前执行，<code>CMD</code> 是延迟执行。不过 <code>RequireJS</code> 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。<code>CMD</code> 推崇 <code>as lazy as possible</code>.<br>2    <code>CMD</code> 推崇依赖就近，<code>AMD</code> 推崇依赖前置<br>3    <code>AMD</code> 的 <code>API</code> 默认是一个当多个用，<code>CMD</code> 的 <code>API</code> 严格区分，推崇职责单一。<br>4    <code>CMD</code>相当于按需加载，定义一个模块的时候不需要立即制定依赖模块，在需要的时候require就可以了，比较方便；而<code>AMD</code>则相反，定义模块的时候需要制定依赖模块。</p><h2 id="为什么要模块化？不用的时候和用RequireJS的时候代码该如何书写"><a href="#为什么要模块化？不用的时候和用RequireJS的时候代码该如何书写" class="headerlink" title="为什么要模块化？不用的时候和用RequireJS的时候代码该如何书写"></a>为什么要模块化？不用的时候和用RequireJS的时候代码该如何书写</h2><p>1    方便大量的js脚本代码的管理维护以及团队配合开发<br>2    有效解决命名空间冲突及文件依赖加载顺序问题<br>3    有利于模块的版本管理，提高可维护性，有利于前端性能优化，跨环境共享模块</p><h2 id="同步和异步模块化的应用场景，AMD异步模块化实现的原理"><a href="#同步和异步模块化的应用场景，AMD异步模块化实现的原理" class="headerlink" title="同步和异步模块化的应用场景，AMD异步模块化实现的原理"></a>同步和异步模块化的应用场景，AMD异步模块化实现的原理</h2><p>引入JS时会遇到需要异步加载文件，此时require.async便可满足异步加载需求</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;对AMD-CMD-CommonJs的理解&quot;&gt;&lt;a href=&quot;#对AMD-CMD-CommonJs的理解&quot; class=&quot;headerlink&quot; title=&quot;对AMD,CMD,CommonJs的理解&quot;&gt;&lt;/a&gt;对AMD,CMD,CommonJs的理解&lt;/h2&gt;</summary>
    
    
    
    <category term="模块化" scheme="http://yoursite.com/categories/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
    
    <category term="模块化" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Webpack,gulp,grunt 等构建工具了解多少，它们有什么区别？Webpack的入口文件如何配置,Webpack的loader和plugins的区别</title>
    <link href="http://yoursite.com/2020/08/28/webpack/"/>
    <id>http://yoursite.com/2020/08/28/webpack/</id>
    <published>2020-08-28T08:51:49.953Z</published>
    <updated>2020-08-28T08:52:55.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack-gulp-grunt-等构建工具了解多少，它们有什么区别？"><a href="#Webpack-gulp-grunt-等构建工具了解多少，它们有什么区别？" class="headerlink" title="Webpack,gulp,grunt 等构建工具了解多少，它们有什么区别？"></a>Webpack,gulp,grunt 等构建工具了解多少，它们有什么区别？</h2><a id="more"></a><p><strong>Webpack</strong>与Gulp、Grunt没有什么可比性，Webpack可以看作模块打包机，通过分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。主要用于模块化方案，预编译模块的方案。<hr><br><strong>gulp</strong>是工具链、构建工具，可以配合各种插件做js压缩，css压缩，less编译 替代手工实现自动化工作，主要是：1.构建工具2.自动化3.提高效率用。相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。<hr><br><strong>Gulp/Grunt</strong>是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。<hr><br><strong>Gulp较之grunt的优势</strong><br><strong>1    易用</strong>， Gulp相比Grunt更简洁，而且遵循代码优于配置策略，维护Gulp更像是写代码。<br><strong>2    高效</strong>， Gulp相比Grunt更有设计感，核心设计基于Unix流的概念，通过管道连接，不需要写中间文件。<br><strong>3    高质量</strong> ，Gulp的每个插件只完成一个功能，各个功能通过流进行整合并完成复杂的任务。例如：Grunt的imagemin插件不仅压缩图片，同时还包括缓存功能。而在Gulp中，缓存是另一个插件，可以被别的插件使用，这样就促进了插件的可重用性。<br><strong>4    易学</strong> ，Gulp的核心API只有5个，掌握了5个API就学会了Gulp，之后便可以通过管道流组合自己想要的任务。<br>5    <strong>代码优于配置</strong> ，维护Gulp更像是写代码，而且Gulp遵循CommonJS规范，因此跟写Node程序没有差别。</p><h2 id="Webpack的入口文件如何配置"><a href="#Webpack的入口文件如何配置" class="headerlink" title="Webpack的入口文件如何配置"></a>Webpack的入口文件如何配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    <span class="comment">//入口文件配置项</span></span><br><span class="line">    entry:&#123;<span class="attr">entry</span>:<span class="string">&#x27;./src/entry.js&#x27;</span>&#125;,</span><br><span class="line">    <span class="comment">//出口文件配置项</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">//输出路劲</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="comment">// 输出文件名称</span></span><br><span class="line">        filename:<span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 模块，例如解读css，图片转换压缩</span></span><br><span class="line">    moudle:&#123;&#125;,</span><br><span class="line">    <span class="comment">// 插件</span></span><br><span class="line">    plugins:&#123;&#125;,</span><br><span class="line">    <span class="comment">// 配置webpack开发服务功能</span></span><br><span class="line">    devServer:&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Webpack的loader和plugins的区别"><a href="#Webpack的loader和plugins的区别" class="headerlink" title="Webpack的loader和plugins的区别"></a>Webpack的loader和plugins的区别</h2><p>loader 用于加载待打包的资源，plugin 用于扩展 webpack。<br>loader 用于加载某些资源文件。 因为webpack 本身只能打包commonjs规范的js文件，对于其他资源例如 css，图片，或者其他的语法集，比如 jsx， coffee，是没有办法加载的。 这就需要对应的loader将资源转化，加载进来。从字面意思也能看出，loader是用于加载的，它作用于一个个文件上。<br>plugin 用于扩展webpack的功能。它直接作用于 webpack，扩展了它的功能。当然loader也时变相的扩展了 webpack ，但是它只专注于转化文件（transform）这一个领域。而plugin的功能更加的丰富，而不仅局限于资源的加载。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Webpack-gulp-grunt-等构建工具了解多少，它们有什么区别？&quot;&gt;&lt;a href=&quot;#Webpack-gulp-grunt-等构建工具了解多少，它们有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;Webpack,gulp,grunt 等构建工具了解多少，它们有什么区别？&quot;&gt;&lt;/a&gt;Webpack,gulp,grunt 等构建工具了解多少，它们有什么区别？&lt;/h2&gt;</summary>
    
    
    
    <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
    <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>js原生拖拽,h5拖拽,jq拖拽</title>
    <link href="http://yoursite.com/2020/08/27/%E6%8B%96%E6%8B%BD/"/>
    <id>http://yoursite.com/2020/08/27/%E6%8B%96%E6%8B%BD/</id>
    <published>2020-08-27T09:34:38.253Z</published>
    <updated>2020-08-27T12:16:16.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js原生拖拽"><a href="#js原生拖拽" class="headerlink" title="js原生拖拽"></a>js原生拖拽</h2><a id="more"></a><p>基本思路如下，拖拽状态 = 0鼠标在元素上按下的时候{<br>    拖拽状态 = 1<br>    记录下鼠标的x和y坐标<br>    记录下元素的x和y坐标<br>   }<br> 鼠标在元素上移动的时候{<br>    如果拖拽状态是0就什么也不做。<br>    如果拖拽状态是1，那么<br>    元素y = 现在鼠标y - 原来鼠标y + 原来元素y<br>    元素x = 现在鼠标x - 原来鼠标x + 原来元素x<br>    }<br> 鼠标在任何时候放开的时候{<br>    拖拽状态 = 0<br>}  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .box &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: red;</span><br><span class="line">        cursor: move;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot; id&#x3D;&quot;drag&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.onload &#x3D; function () &#123;</span><br><span class="line">            var drag &#x3D; document.getElementById(&#39;drag&#39;);</span><br><span class="line">            &#x2F;&#x2F; &#x2F;&#x2F;点击某物体时，用drag对象即可，move和up是全局区域，</span><br><span class="line">            &#x2F;&#x2F; 也就是整个文档通用，应该使用document对象而不是drag对象(否则，采用drag对象时物体只能往右方或下方移动)  </span><br><span class="line">            drag.onmousedown &#x3D; function (event) &#123;</span><br><span class="line">                var event &#x3D; event || window.event; &#x2F;&#x2F;兼容IE浏览器</span><br><span class="line">                &#x2F;&#x2F;    鼠标点击物体那一刻相对于物体左侧边框的距离&#x3D;点击时的位置相对于浏览器最左边的距离-物体左边框相对于浏览器最左边的距离</span><br><span class="line">                var diffX &#x3D; event.clientX - drag.offsetLeft;</span><br><span class="line">                var diffY &#x3D; event.clientY - drag.offsetTop;</span><br><span class="line">                if (typeof drag.setCapture !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">                    drag.setCapture();</span><br><span class="line">                &#125;</span><br><span class="line">                document.onmousemove &#x3D; function (event) &#123;</span><br><span class="line">                    var event &#x3D; event || window.event;</span><br><span class="line">                    var moveX &#x3D; event.clientX - diffX;</span><br><span class="line">                    var moveY &#x3D; event.clientY - diffY;</span><br><span class="line">                    if (moveX &lt; 0) &#123;</span><br><span class="line">                        moveX &#x3D; 0</span><br><span class="line">                    &#125; else if (moveX &gt; window.innerWidth - drag.offsetWidth) &#123;</span><br><span class="line">                        moveX &#x3D; window.innerWidth - drag.offsetWidth</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (moveY &lt; 0) &#123;</span><br><span class="line">                        moveY &#x3D; 0</span><br><span class="line">                    &#125; else if (moveY &gt; window.innerHeight - drag.offsetHeight) &#123;</span><br><span class="line">                        moveY &#x3D; window.innerHeight - drag.offsetHeight</span><br><span class="line">                    &#125;</span><br><span class="line">                    drag.style.left &#x3D; moveX + &#39;px&#39;;</span><br><span class="line">                    drag.style.top &#x3D; moveY + &#39;px&#39;</span><br><span class="line">                &#125;</span><br><span class="line">                document.onmouseup &#x3D; function (event) &#123;</span><br><span class="line">                    this.onmousemove &#x3D; null;</span><br><span class="line">                    this.onmouseup &#x3D; null;</span><br><span class="line">                    &#x2F;&#x2F;修复低版本ie bug  </span><br><span class="line">                    if (typeof drag.releaseCapture !&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">                        drag.releaseCapture();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="h5拖拽"><a href="#h5拖拽" class="headerlink" title="h5拖拽"></a>h5拖拽</h2><p>参考： <a href="https://www.cnblogs.com/lhl66/p/8867697.html">https://www.cnblogs.com/lhl66/p/8867697.html</a><br>draggable 属性规定元素是否可拖动（HTML5 新增）<br>语法：<element draggable="true|false|auto"><br>true //规定元素是可拖动的。<br>false //规定元素是不可拖动的。<br>auto //使用浏览器的默认特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">        #div1 &#123;</span><br><span class="line">            width: 300px;</span><br><span class="line">            height: 160px;</span><br><span class="line">            padding: 10px;</span><br><span class="line">            border: 1px solid #aaaaaa;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">        &#x2F;&#x2F;放到何处 - ondragover</span><br><span class="line">        function allowDrop(ev) &#123;</span><br><span class="line">            ev.preventDefault(); &#x2F;&#x2F;drop事件的默认行为是以链接形式打开</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;拖动什么 - ondragstart 和 setData()</span><br><span class="line">        function drag(ev) &#123;</span><br><span class="line">            ev.dataTransfer.setData(&quot;Text&quot;, ev.target.id); &#x2F;&#x2F;dataTransfer.setData() 方法设置被拖数据的数据类型和值</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;进行放置 - ondrop</span><br><span class="line">        function drop(ev) &#123;</span><br><span class="line">            ev.preventDefault();</span><br><span class="line">            var data &#x3D; ev.dataTransfer.getData(&quot;Text&quot;);</span><br><span class="line">            ev.target.appendChild(document.getElementById(data));</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;请把下面的图片拖拽到上面的矩形里面&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;div1&quot; ondrop&#x3D;&quot;drop(event)&quot; ondragover&#x3D;&quot;allowDrop(event)&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;br &#x2F;&gt;</span><br><span class="line">    &lt;img id&#x3D;&quot;drag1&quot; src&#x3D;&quot;https:&#x2F;&#x2F;ss3.baidu.com&#x2F;-rVXeDTa2gU2pMbgoY3K&#x2F;it&#x2F;u&#x3D;1402111932,1875120122&amp;fm&#x3D;202&amp;mola&#x3D;new&amp;crop&#x3D;v1&quot;</span><br><span class="line">        draggable&#x3D;&quot;true&quot; ondragstart&#x3D;&quot;drag(event)&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="jquery横向滑动"><a href="#jquery横向滑动" class="headerlink" title="jquery横向滑动"></a>jquery横向滑动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .box&#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: black;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;upcdn.b0.upaiyun.com&#x2F;libs&#x2F;jquery&#x2F;jquery-2.0.2.min.js&quot; &gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;    jq拖拽横向滑动</span><br><span class="line">    $(&#39;.box&#39;).on(&#123;</span><br><span class="line">            mousedown:function(e)&#123;</span><br><span class="line">                var el &#x3D; $(this);</span><br><span class="line">                var os &#x3D; el.offset();</span><br><span class="line">                dx &#x3D; e.pageX - os.left;</span><br><span class="line">                $(document).on(&#39;mousemove.drag&#39;,function(e)&#123;</span><br><span class="line">                    el.offset(&#123;</span><br><span class="line">                        left: e.pageX - dx</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;).on(&#39;mouseup&#39;,function(e)&#123;</span><br><span class="line">                    $(document).off(&#39;mousemove.drag&#39;);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="jquery自由滑动"><a href="#jquery自由滑动" class="headerlink" title="jquery自由滑动"></a>jquery自由滑动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .box &#123;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: black;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;http:&#x2F;&#x2F;upcdn.b0.upaiyun.com&#x2F;libs&#x2F;jquery&#x2F;jquery-2.0.2.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F;    jq拖拽自由拖动</span><br><span class="line">        $(&quot;.box&quot;).on(&#123;</span><br><span class="line">            mousedown: function (e) &#123;</span><br><span class="line">                var el &#x3D; $(this);</span><br><span class="line">                var os &#x3D; el.offset();</span><br><span class="line">                dx &#x3D; e.pageX - os.left, dy &#x3D; e.pageY - os.top;</span><br><span class="line">                $(document).on(&#39;mousemove.drag&#39;, function (e) &#123;</span><br><span class="line">                    el.offset(&#123;</span><br><span class="line">                        top: e.pageY - dy,</span><br><span class="line">                        left: e.pageX - dx</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;).on(&#39;mouseup&#39;, function (e) &#123;</span><br><span class="line">                    $(document).off(&#39;mousemove.drag&#39;);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;js原生拖拽&quot;&gt;&lt;a href=&quot;#js原生拖拽&quot; class=&quot;headerlink&quot; title=&quot;js原生拖拽&quot;&gt;&lt;/a&gt;js原生拖拽&lt;/h2&gt;</summary>
    
    
    
    <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
    <category term="拖拽" scheme="http://yoursite.com/tags/%E6%8B%96%E6%8B%BD/"/>
    
  </entry>
  
  <entry>
    <title>XMLHttpRequest实例状态，DNS，服务器如何识别是你在操作，浏览器的渲染流程，IE浏览器的兼容问题，Session，URL的各个部分</title>
    <link href="http://yoursite.com/2020/08/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B32/"/>
    <id>http://yoursite.com/2020/08/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B32/</id>
    <published>2020-08-27T09:26:36.970Z</published>
    <updated>2020-08-27T09:34:16.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XMLHttpRequest实例状态"><a href="#XMLHttpRequest实例状态" class="headerlink" title="XMLHttpRequest实例状态"></a>XMLHttpRequest实例状态</h2><a id="more"></a><p>XMLHttpRequest的几种状态<br>0    对象没有完成初始化<br>1    对象开始发送请求<br>2    对象的请求发送完成<br>3    对象开始读取服务器响应<br>4    对象读取服务器响应结束</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。<br>查询<a href="http://www.163.com的dns请求到达本地dns服务器之后,本地dns服务器会首先查询它的缓存记录,如果缓存中有此条记录,就可以直接返回结果.如果没有,本地dns服务器还要向dns根服务器进行查询./">www.163.com的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</a><br>根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。<br>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。<br>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问</p><h2 id="服务器如何识别是你在操作"><a href="#服务器如何识别是你在操作" class="headerlink" title="服务器如何识别是你在操作"></a>服务器如何识别是你在操作</h2><p>①当浏览器首次访问服务器时,服务器会为客户端创建一个session（每个用户独有的房间，用来存放这个对象的相关信息和内容），并通过特殊算法算出一个sessionID（类似于双方都知道的唯一暗号），用来标识该session对象。<br>    ②当浏览器再次（session还在有效时间内）向服务器请求资源的时候，浏览器将sessionID和请求内容一起发送到服务端。服务端通过对比自身存储的sessionId来判断用户之前是否存在，并返回对应的内容给不同用户。<br>    ③因为标识符存在内存里，所以当浏览器关闭时，浏览器保存的sessionId就会消失。服务器将匹配失败，默认为此请求是新用户提出的，如上文顺序，重新创建一个session容器，和相应的唯一sessionId，返回给浏览器。<br>一分钟专业解释：<br>                  ① 服务器在响应头内加上”Set-Cookie:XXXXXXXXXXXXX“(相当于一个唯一的ID符)，此信息是服务器随机生成的，放在服务器内存里，不会重复,这就是sessionid。<br>                  ②当浏览器得到这个sessionid会将它放在自己的进程内存里,.然后你继续发请求给这个网站的时候,浏览器就会把这个sessionid放在请求头里发送给该服务器了,这样服务器得到sessionid后再和自己内存里存放的sessionid对比锁定客户端,从而区分不同客户端,完成会话.<br>                  ③关闭浏览器结束进程,则这个sessionid将消失,如果用户又打开浏览器想继续这次会话的时候,就会因为发送的请求中没有这个sessionid，而使服务器无法辨别请求身份。 </p><h2 id="浏览器的渲染流程"><a href="#浏览器的渲染流程" class="headerlink" title="浏览器的渲染流程"></a>浏览器的渲染流程</h2><p>1    解析HTML文件，创建DOM树<br>2    解析CSS：优先级：浏览器默认设置&lt;用户设置&lt;外部样式&lt;内联样式&lt;HTML中的style样式<br>3    将CSS与DOM合并，构建渲染树<br>4    布局和绘制，重绘（repaint）和重排（reflow）<br>重排：若渲染树的一部分更新，且尺寸变化，就会发生重排；<br>重绘：部分节点需要更新，但不改变其他集合形状。如改变某个元素的颜色，就会发生重绘</p><h2 id="IE浏览器的兼容问题"><a href="#IE浏览器的兼容问题" class="headerlink" title="IE浏览器的兼容问题"></a>IE浏览器的兼容问题</h2><p>1    块属性标签float之后，又有横向的margin值，在IE6中显示会比设置的大（IE6双边距bug）<br>2    设置较小的高度标签（一般小于10px），在IE6，IE7，会超出自己设置的高度，解决办法：设置较小的高度标签（一般小于10px），在IE6，IE7，遨游中超出自己设置的高度<br>3    图片默认有间距，解决方案：使用float为img布局<br>4    给一个元素设置了高度和宽度的同时，还为其设置margin和padding的值，会改变该元素的实际大小。解决办法：在需要加 margin和padding的div内部加一个div,在这个div里设置margin和padding值</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>session是存放在服务器的内存中里，所以session里的数据不断增加会造成服务器的负担，所以会把很重要的信息存储在session中，session的信息是通过sessionid获取的，而sessionid是存放在会话cookie当中的，当浏览器关闭的时候会话cookie消失，所以sessionid也就消失了，但是session的信息还存在服务器端。一般session是和cookie结合起来使用的</p><h2 id="URL的各个部分"><a href="#URL的各个部分" class="headerlink" title="URL的各个部分"></a>URL的各个部分</h2><p>例如：scheme://host:port/path?query#fragment<br>1    .scheme:通信协议，常用的http,ftp,maito等<br>2    .host:主机，服务器(计算机)域名系统 (DNS) 主机名或 IP 地址<br>3    .port:端口号，整数，可选，省略时使用方案的默认端口，如http的默认端口为80<br>4    .path:路径，由零或多个”/“符号隔开的字符串，一般用来表示主机上的一个目录或文件地址<br>5    .query:查询，可选，用于给动态网页传递参数，可有多个参数，用”&amp;”符号隔开，每个参数的名和值用”=”符号隔开<br>6    .fragment:信息片断，字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。(也称为锚点)</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;XMLHttpRequest实例状态&quot;&gt;&lt;a href=&quot;#XMLHttpRequest实例状态&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest实例状态&quot;&gt;&lt;/a&gt;XMLHttpRequest实例状态&lt;/h2&gt;</summary>
    
    
    
    <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>跨域，前端安全XSS,CSRF,浏览器如何加载页面的，script脚本阻塞有什么解决办法，defer和async的区别是什么,浏览器强制缓存和协商缓存,浏览器的全局变量,浏览器同一时间能够从一个域名下载多少个资源,按需加载，不同页面的元素判断标准是怎么样的,WEB存储，COOKIES,LOCALSTOGE等的使用规则和区别,浏览器内核,预加载，懒加载</title>
    <link href="http://yoursite.com/2020/08/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2020/08/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2020-08-27T08:15:46.499Z</published>
    <updated>2020-08-27T09:26:22.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><a id="more"></a><p>跨域,指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的,是浏览器对javascript施加的安全限制，防止他人恶意攻击网站<br>比如一个黑客,他利用iframe把真正的银行登录页面嵌到他的页面上,当你使用真实的用户名和密码登录时,如果没有同源限制,他的页面就可以通过 JavaScript读取到你的表单中输入的内容,这样用户名和密码就轻松到手了。</p><h2 id="前端安全XSS-CSRF"><a href="#前端安全XSS-CSRF" class="headerlink" title="前端安全XSS,CSRF"></a>前端安全XSS,CSRF</h2><p><strong>xss</strong> 跨站脚本攻击。xss攻击的主要目的是想办法获取目标攻击网站的cookie， 因为有了cookie相当于有了session。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该网页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的，避免采取的措施：编码、过滤、校验</p><hr><p><strong>csrf</strong> 跨站点伪装请求，CSRF攻击者在用户已经登录目标网站之后，诱使用户访问一个攻击页面，利用目标网站对用户的信任，以用户身份在攻击页面对目标网站发起伪造用户操作的请求，达到攻击目的。防御手段：1. 尽量使用POST，限制GET，2. 加验证码</p><h2 id="浏览器如何加载页面的，script脚本阻塞有什么解决办法，defer和async的区别是什么"><a href="#浏览器如何加载页面的，script脚本阻塞有什么解决办法，defer和async的区别是什么" class="headerlink" title="浏览器如何加载页面的，script脚本阻塞有什么解决办法，defer和async的区别是什么"></a>浏览器如何加载页面的，script脚本阻塞有什么解决办法，defer和async的区别是什么</h2><p>从浏览器地址栏的请求链接开始，浏览器通过DNS解析查到域名映射的IP地址，成功之后浏览器端向此IP地址取得连接，成功连接之后，浏览器端将请求信息通过HTTP协议向此IP地址所在服务器发起请求，服务器接受到请求之后等待处理，最后向浏览器端发回响应，此时在HTTP协议下，浏览器从服务器接收到 text/html类型的代码，浏览器开始显示此html，并获取其中内嵌资源地址，然后浏览器再发起请求来获取这些资源，并在浏览器的html中显示<br><strong>1    推迟加载（延迟加载）</strong><br>如果页面初始的渲染并不依赖于js或者CSS可以用推迟加载，就是最后在加载js和css，把引用外部文件的代码写在最后<br><strong>2    defer延迟加载</strong><br><code>&lt;script src=&quot;&quot; defer&gt;&lt;/script&gt;</code> 在文档解析完成开始执行，并且在DOMContentLoaded事件之前执行完成，会按照他们在文档出现的顺序去下载解析。效果和把script放在文档最后<code>&lt;/body&gt;</code>之前是一样的。<br>          注：defer最好用在引用外部文件中使用，用了<code>defer</code>不要使用<code>document.write()</code>方法;使用defer时最好不要请求样式信息，因为样式表可能尚未加载，浏览器会禁止该脚本等待样式表加载完成，相当于样式表阻塞脚本执行<br><strong>3    异步加载</strong><br>async异步加载：就是告诉浏览器不必等到加载完外部文件，可以边渲染边下载，什么时候下载完成什么时候执行。<code>&lt;script type=&quot;text/javascript&quot; src=&quot;a.js&quot; async&gt;&lt;/script&gt;</code><br>defer和async的区别：<code>&lt;script async src=&quot;example.js&quot;&gt;&lt;/script&gt;</code>有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行；<code>&lt;script defer src=&quot;example.js&quot;&gt;&lt;/script&gt;</code><br>有了defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本的执行需要等到文档所有元素解析完成之后，<code>DOMContentLoaded</code>事件触发执行之前</p><h2 id="浏览器强制缓存和协商缓存"><a href="#浏览器强制缓存和协商缓存" class="headerlink" title="浏览器强制缓存和协商缓存"></a>浏览器强制缓存和协商缓存</h2><p><strong>强制缓存</strong>：是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间<br><strong>协商缓存</strong>：就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段</p><h2 id="浏览器的全局变量"><a href="#浏览器的全局变量" class="headerlink" title="浏览器的全局变量"></a>浏览器的全局变量</h2><p>有：alert，location，open()，setTimeout()，clearInterval()等</p><h2 id="浏览器同一时间能够从一个域名下载多少个资源"><a href="#浏览器同一时间能够从一个域名下载多少个资源" class="headerlink" title="浏览器同一时间能够从一个域名下载多少个资源"></a>浏览器同一时间能够从一个域名下载多少个资源</h2><p>一般是限制在10个以内</p><h2 id="按需加载，不同页面的元素判断标准是怎么样的"><a href="#按需加载，不同页面的元素判断标准是怎么样的" class="headerlink" title="按需加载，不同页面的元素判断标准是怎么样的"></a>按需加载，不同页面的元素判断标准是怎么样的</h2><p>访问的数据量过大的时候用缓存明显不太合适的时候。可以用按需加载</p><h2 id="WEB存储，COOKIES-LOCALSTOGE等的使用规则和区别"><a href="#WEB存储，COOKIES-LOCALSTOGE等的使用规则和区别" class="headerlink" title="WEB存储，COOKIES,LOCALSTOGE等的使用规则和区别"></a>WEB存储，COOKIES,LOCALSTOGE等的使用规则和区别</h2><p>web存储就指的是本地存储，包括localstorage和sessionstorage<br>Cookies:cookie在浏览器与服务器之间来回传递，cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭，cookie数据不能超过4k。<br>localStorage:localStorage不把数据发给服务器，仅在本地保存,始终有效，长期保存,可以达到5M或更大存储大小</p><h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>火狐浏览器：Mozilla Firefox ，内核是Gecko<br>opera浏览器：内核是blink<br>Safari浏览器：使用的是苹果公司自己的内核:webkit<br>一些国内的浏览器他们的内核<br>搜狗浏览器：    兼容模式（IE：Trident）和高速模式（webkit）<br>傲游浏览器：    兼容模式（IE：Trident）和高速模式（webkit）<br>QQ浏览器：    普通模式（IE：Trident）和极速模式（webkit）<br>360极速浏览器：    基于谷歌（Chromium）和IE内核<br>360安全浏览器：    IE内核</p><h2 id="预加载，懒加载"><a href="#预加载，懒加载" class="headerlink" title="预加载，懒加载"></a>预加载，懒加载</h2><p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染<br>懒加载：也就是延迟加载。当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次，俗称占位图），只有当图片出现在浏览器的可视区域内时，才设置图片真正的路径，让图片显示出来。这就是图片懒加载</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;跨域&quot;&gt;&lt;a href=&quot;#跨域&quot; class=&quot;headerlink&quot; title=&quot;跨域&quot;&gt;&lt;/a&gt;跨域&lt;/h2&gt;</summary>
    
    
    
    <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>为什么TCP连接需要三次握手，为什么TCP连接需要三次握手四次挥手，TCP的三次握手和四次挥手绘图（画写ACK和SEQ的值），TCP与UDP的区别，Get和Post的区别？什么情况下用到，HTTP2 / HTTP1  之间的区别，websocket，HTTP Response的Header里面都有什么</title>
    <link href="http://yoursite.com/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/"/>
    <id>http://yoursite.com/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/</id>
    <published>2020-08-26T08:30:14.722Z</published>
    <updated>2020-08-26T08:57:00.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么TCP连接需要三次握手"><a href="#为什么TCP连接需要三次握手" class="headerlink" title="为什么TCP连接需要三次握手"></a>为什么TCP连接需要三次握手</h2><a id="more"></a><p>三次握手为了确认客户端跟服务器都能接受到对方的信息,两次的话服务器不能确认客户端能否接收自己发的包<hr>第一次握手，客户端给服务器发包。 此时服务器确认自己可以接收客户端的包，客户端不确认服务器是否接收到了自己发的包<hr>第二次握手，服务器端回复客户端。 此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包<hr>第三次握手，客户端回复服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的包。两边都没有问题，开始通信<hr>简单概括：第一次：服务端和客户端建立联系；第二次：服务器端回复客户端；第三次：客户端回复服务器</p><h2 id="为什么TCP连接需要三次握手四次挥手"><a href="#为什么TCP连接需要三次握手四次挥手" class="headerlink" title="为什么TCP连接需要三次握手四次挥手"></a>为什么TCP连接需要三次握手四次挥手</h2><p><strong>为什么是三次握手？</strong><br>为了防止已失效的连接请求报文段突然有送到了服务器，因而产生错误,假设两次握手时，客户发出的第一个请求连接报文段在某一网络节点长时间滞留，以致延误到连接释放后才到达服务器。服务器收到失效的连接请求报文段后，认为是客户又发出一次新的连接请求。于是向客户发送确认报文段，同意建立连接，此时在假定两次握手的前提下，连接建立成功。这样会导致服务器的资源白白浪费<hr><br><strong>为什么是四次挥手？</strong><br>TCP协议是全双工通信，这意味着客户端和服务器端都可以向彼此发送数据，所以关闭连接是双方都需要确认的共同行为，假设是三次挥手时，首先释放了客户到服务器方向的连接，此时TCP连接处于半关闭状态，这时客户不能向服务器发送数据，而服务器还是可以向客户发送数据。如果此时客户收到了服务器的确认报文段后，就立即发送一个确认报文段，这会导致服务器向客户还在发送数据时连接就被关闭。这样会导致客户没有完整收到服务器所发的报文段</p><h2 id="TCP的三次握手和四次挥手绘图（画写ACK和SEQ的值）"><a href="#TCP的三次握手和四次挥手绘图（画写ACK和SEQ的值）" class="headerlink" title="TCP的三次握手和四次挥手绘图（画写ACK和SEQ的值）"></a>TCP的三次握手和四次挥手绘图（画写ACK和SEQ的值）</h2><p>所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。由客户端执行connect()触发<br> <img src="https://img-blog.csdnimg.cn/20200826163516943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。由客户端或服务端任一方执行close来触发<br> <img src="https://img-blog.csdnimg.cn/20200826163525911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议<br>UDP(User Datagram Protocol用户数据报协议）是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务<br>TCP 是面向连接的传输控制协议，而UDP提供了无链接的数据报服务//类似电话与短信<br>TCP 面向连接，提供可靠的数据服务<br>TCP首部开销20字节,UDP首部开销8字节<br>TCP逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道<br>UDP没有拥塞机制，因此网络出现拥堵不会使源主机的发送效率降低（有利于实时会议视频等）<br>TCP的连接只能是点到点的,UDP支持一对一，多对一，多对多的交互通信</p><h2 id="Get和Post的区别？什么情况下用到"><a href="#Get和Post的区别？什么情况下用到" class="headerlink" title="Get和Post的区别？什么情况下用到"></a>Get和Post的区别？什么情况下用到</h2><p>1    GET使用URL或Cookie传参。而POST将数据放在BODY中<br>2    GET的URL会有长度上的限制，则POST的数据则可以非常大<br>3    POST比GET安全，因为数据在地址栏上不可见<br><strong>最本质的区别</strong><br>Get是用来从服务器上获得数据，而post是用来向服务器上传递数据<br><strong>若符合下列任一情况，则用post方法：</strong><br>a    请求的结果有持续性的作用，例如：数据库内添加新的数据行<br>b    若使用get方法，则表单上收集的数据可能让URL过长<br>c    要传送的数据不是采用ASCII编码<br><strong>若符合下列任一情况，则用get方法：</strong><br>a    请求是为了查找资源，html表单数据仅用来搜索<br>b    请求结果无持续性的副作用<br>c    收集的数据及html表单内的输入字段名称的总长不超过1024个字符</p><h2 id="HTTP2-HTTP1-之间的区别"><a href="#HTTP2-HTTP1-之间的区别" class="headerlink" title="HTTP2 / HTTP1  之间的区别"></a>HTTP2 / HTTP1  之间的区别</h2><p>1    http2采用二进制格式而非文本格式，比起文本格式，二进制格式解析起来更加高效，并且错误少<br>2    http2是完全的多路复用，非有序并阻塞的—-只需要一个连接即可实现并行，多路复用的意思是它能同时处理多个消息的请求和响应，http1是一个连接一次只能提交一个请求的效率比较高，多了就会变慢<br>3    使用报头压缩，http2降低了开销，http1的消息头很大冗余,http2是将消息头中的不同的部分分别用不用的索引进行表示，且会用哈夫曼编码压缩字符串，最后封装成frame<br>4    http2让服务器可以将响应主动”推送”到客户端缓存中，HTTP2中服务器会主动将资源推送给客户端，例如把js和css文件主动推送给客户端而不用客户端解析HTML后请求再响应</p><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>websocket是一种网络通信协议，是HTML5开始提供的一种在单个TCP连接上进行全双工通信的协议，这个对比着http协议来说，http协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。http协议无法实现服务器主动向客户端发起消息，Websocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个webSocket对象</span><br><span class="line">var ws &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;localhost:9998&#x2F;echo&#39;);</span><br><span class="line">&#x2F;&#x2F; 建立webSocket连接成功触发事件</span><br><span class="line">ws.onopen &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F;使用send方法接收数据</span><br><span class="line">    ws.send(&#39;发送数据&#39;)</span><br><span class="line">    alert(&#39;数据发送中&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 接收服务端数据时触发事件</span><br><span class="line">ws.onmessage &#x3D; function (evt) &#123;</span><br><span class="line">    var received_msg &#x3D; evt.data</span><br><span class="line">    alert(&#39;数据已接收&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;断开webSocket连接成功触发事件</span><br><span class="line">ws.onclose &#x3D; function () &#123;</span><br><span class="line">    alert(&#39;数据已关闭&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP-Response的Header-里面都有什么"><a href="#HTTP-Response的Header-里面都有什么" class="headerlink" title="HTTP Response的Header 里面都有什么"></a>HTTP Response的Header 里面都有什么</h2><p>1    Cache-Control：告诉所有的缓存机制是否可以缓存及哪种类型<br>2    Content-Length：响应体的长度<br>3    Content-Type：返回内容的MIME类型，所谓的MIME就是解析的是什么，比方说：jpg就是图片<br>4    Expires：响应过期的日期和时间<br>5    Set-Cookie：设置Http Cookie</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么TCP连接需要三次握手&quot;&gt;&lt;a href=&quot;#为什么TCP连接需要三次握手&quot; class=&quot;headerlink&quot; title=&quot;为什么TCP连接需要三次握手&quot;&gt;&lt;/a&gt;为什么TCP连接需要三次握手&lt;/h2&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议头包含哪些重要部分，HTTP状态码。网络url输入到输出都做了什么，为什么说性能优化就要减少HTTP的访问次数，HTTP的请求过程与原理，HTTP的请求过程与原理，TLS的中文名？TLS在那一网络层，TCP连接的特点，TCP连接如何保证安全可靠</title>
    <link href="http://yoursite.com/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"/>
    <id>http://yoursite.com/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/</id>
    <published>2020-08-26T08:28:14.957Z</published>
    <updated>2020-08-26T08:56:44.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP协议头包含哪些重要部分，HTTP状态码。"><a href="#HTTP协议头包含哪些重要部分，HTTP状态码。" class="headerlink" title="HTTP协议头包含哪些重要部分，HTTP状态码。"></a>HTTP协议头包含哪些重要部分，HTTP状态码。</h2><a id="more"></a><p>HTTP协议头包括通用头，请求头，响应头和实体头四个部分<br>200    请求已成功，请求所希望的响应头或数据体将随此响应返回<br>302    Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置<br>304    Not Modified（未修改）客户的缓存资源是最新的， 要客户端使用缓存<br>404    Not Found 未找到资源，可能是路径方面的错误<br>503    服务器目前无法为请求提供服务，但过一段时间就可以恢复服务</p><h2 id="网络url输入到输出都做了什么"><a href="#网络url输入到输出都做了什么" class="headerlink" title="网络url输入到输出都做了什么"></a>网络url输入到输出都做了什么</h2><p>1    当我们输入一个域名像：<a href="http://www.baidu.com/">www.baidu.com</a> </p><p>2    浏览器查找浏览器缓存，如果有域名的IP地址则返回，如果没有继续查找<br>3    系统查找系统缓存，如果有域名的IP地址则返回，如果没有继续查找<br>4    路由器查找路由器缓存，如果有域名的IP地址则返回，如果没有继续查找<br>5    本地域名服务器采用迭代查询，它先向一个根域名服务器查询<br>6    根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.com的IP地址<br>7    本地域名服务器向顶级域名服务器dns.com进行查询<br>8    顶级域名服务器dns.com告诉本地域名服务器，下一次应查询的权限域名服务器dns.baidu.com的IP地址<br>9    本地域名服务器向权限域名服务器dns.baidu.com进行查询<br>10    权限域名服务器dns.baidu.com告诉本地域名服务器，所查询的主机<a href="http://www.baidu.com的ip地址/">www.baidu.com的IP地址</a><br>11    本地域名服务器最后把查询结果告诉主机<br>12    主机浏览器获取到Web服务器的IP地址后，与服务器建立TCP连接<br>13    浏览器所在的客户机向服务器发出连接请求报文<br>14    服务器接收报文后，同意建立连接，向客户机发出确认报文<br>15    客户机接收到确认报文后，再次向服务器发出报文，确认已接收到确认报文<br>16    此处客户机与服务器之间的TCP连接建立完成，开始通信<br>17    浏览器发出取文件命令：GET<br>18    服务器给出响应，将指定文件发送给浏览器<br>19    浏览器释放TCP连接<br>20    浏览器所在主机向服务器发出连接释放报文，然后停止发送数据<br>21    服务器接收到释放报文后发出确认报文，然后将服务器上未传送完的数据发送完<br>22    服务器数据传输完毕后，向客户机发送连接释放报文<br>23    客户机接收到报文后，发出确认，然后等待一段时间后，释放TCP连接<br>24    浏览器显示页面中所有文本</p><h2 id="为什么说性能优化就要减少HTTP的访问次数"><a href="#为什么说性能优化就要减少HTTP的访问次数" class="headerlink" title="为什么说性能优化就要减少HTTP的访问次数"></a>为什么说性能优化就要减少HTTP的访问次数</h2><p>1    http请求头的数据量：每次请求都会带上一些额外的信息进行传输,所以请求越多的时候，在网络上传输的数据就会变多了，速度就变慢了<br>2    http连接的开销：从用户输入URL到看到页面，经过一系列的解析和连接，以及等待</p><h2 id="HTTP的请求过程与原理"><a href="#HTTP的请求过程与原理" class="headerlink" title="HTTP的请求过程与原理"></a>HTTP的请求过程与原理</h2><p><strong>http请求的过程：</strong> 域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt;服务器响应http请求，浏览器得到html代码 –&gt;浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户<br><strong>请求原理：</strong> HTTP协议是应用层的一种协议，是一种C/S架构服务，基于TCP/IP协议来通信，监听在TCP的80端口上，HTTP协议实现的是客户端可以向服务端获得web资源</p><h2 id="https有几次握手和挥手，https的原理"><a href="#https有几次握手和挥手，https的原理" class="headerlink" title="https有几次握手和挥手，https的原理"></a>https有几次握手和挥手，https的原理</h2><p>https是3次握手和4次挥手，和http是一样的。<br>原理：https在传输数据前需要客户端(浏览器)与服务器(网站)之间进行一次握手,在握手过程中将确立双方加密传输数据的密码信息.TLS/SSL协议是一套加密传输协议,使用了非对称加密,对称加密,以及HASH算法</p><h2 id="TLS的中文名？TLS在那一网络层"><a href="#TLS的中文名？TLS在那一网络层" class="headerlink" title="TLS的中文名？TLS在那一网络层"></a>TLS的中文名？TLS在那一网络层</h2><p>TLS的中文名是：安全传输层协议，在传输层。</p><h2 id="TCP连接的特点，TCP连接如何保证安全可靠"><a href="#TCP连接的特点，TCP连接如何保证安全可靠" class="headerlink" title="TCP连接的特点，TCP连接如何保证安全可靠"></a>TCP连接的特点，TCP连接如何保证安全可靠</h2><p>TCP的可靠性是通过顺序编号和确认（ACK）来实现的，TCP的接收端必须丢弃重复的数据，并且TCP提供流量控制，连接的每一个地方都有固定大小的缓冲空间。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;HTTP协议头包含哪些重要部分，HTTP状态码。&quot;&gt;&lt;a href=&quot;#HTTP协议头包含哪些重要部分，HTTP状态码。&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议头包含哪些重要部分，HTTP状态码。&quot;&gt;&lt;/a&gt;HTTP协议头包含哪些重要部分，HTTP状态码。&lt;/h2&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>es6--Promise如何封装一个AJAX</title>
    <link href="http://yoursite.com/2020/08/25/Promise%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAAJAX/"/>
    <id>http://yoursite.com/2020/08/25/Promise%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAAJAX/</id>
    <published>2020-08-25T12:54:51.531Z</published>
    <updated>2020-08-25T13:17:17.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="es6–promise"><a href="#es6–promise" class="headerlink" title="es6–promise"></a>es6–promise</h2><a id="more"></a><p>　Promise的出现主要是解决地狱回调的问题，比如你需要结果需要请求很多个接口，这些接口的参数需要另外那个的接口返回的数据作为依赖，这样就需要我们一层嵌套一层，但是有了Promise 我们就无需嵌套<br>　参考：<a href="https://www.cnblogs.com/elexmiumiu/p/12196122.html">https://www.cnblogs.com/elexmiumiu/p/12196122.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">function ajax(optionsOverride)&#123;</span><br><span class="line">    &#x2F;&#x2F;将传入的参数与默认的合并</span><br><span class="line">    var options &#x3D; &#123;&#125;</span><br><span class="line">    for(var k in ajaxOptions)&#123;</span><br><span class="line">        options[k] &#x3D; optionsOverride[k] || ajaxOptions[k]</span><br><span class="line">    &#125;</span><br><span class="line">    options.async &#x3D; options.async &#x3D;&#x3D;&#x3D; false ? false : true</span><br><span class="line">    var xhr &#x3D; options.xhr &#x3D; options.xhr || new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">    return new Promise(function(resolve,reject)&#123;</span><br><span class="line">        xhr.open(options.method,options.url,options.async)</span><br><span class="line">        xhr.timeout &#x3D; options.timeout</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;设置请求头</span><br><span class="line">        for(var k in options.headers)&#123;</span><br><span class="line">            xhr.setRuquestHeader(k,options,headers[k])</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;注册xhr对象事件</span><br><span class="line">        xhr.onprogress &#x3D; options.onprogress</span><br><span class="line">        xhr.onload.onprogress &#x3D; options.onploadprogress</span><br><span class="line">        xhr.responseType &#x3D; options.dataType</span><br><span class="line"></span><br><span class="line">        xhr.onabort &#x3D; function()&#123;</span><br><span class="line">            reject(new Error(&#123;</span><br><span class="line">                errorType: &#39;abort_error&#39;,</span><br><span class="line">                xhr:xhr</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xhr.ontimeout &#x3D; function()&#123;</span><br><span class="line">            reject(&#123;</span><br><span class="line">                errorType: &#39;timeout_error&#39;,</span><br><span class="line">                xhr:xhr</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        xhr.onerror &#x3D; function()&#123;</span><br><span class="line">            reject(&#123;</span><br><span class="line">                errorType: &#39;onerror&#39;,</span><br><span class="line">                xhr:xhr</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xhr.onloadend &#x3D; function()&#123;</span><br><span class="line">            if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status&lt; 300) || xhr.status &#x3D;&#x3D; 304) &#123;</span><br><span class="line">                resolve(xhr)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                reject(&#123;</span><br><span class="line">                    errorType: &#39;status_error&#39;,</span><br><span class="line">                    xhr:xhr</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                xhr.send(options.data)</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                reject(&#123;</span><br><span class="line">                    errorType: &#39;send_error&#39;,</span><br><span class="line">                    error:e</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;es6–promise&quot;&gt;&lt;a href=&quot;#es6–promise&quot; class=&quot;headerlink&quot; title=&quot;es6–promise&quot;&gt;&lt;/a&gt;es6–promise&lt;/h2&gt;</summary>
    
    
    
    <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
    <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6--ES6特性</title>
    <link href="http://yoursite.com/2020/08/25/ES6%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2020/08/25/ES6%E7%89%B9%E6%80%A7/</id>
    <published>2020-08-25T12:49:29.786Z</published>
    <updated>2020-08-26T09:15:54.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="es6–ES6特性"><a href="#es6–ES6特性" class="headerlink" title="es6–ES6特性"></a>es6–ES6特性</h2><a id="more"></a><p><strong>常用的es6新特性：</strong></p><ol><li>let &amp;&amp; const<br>let命令也用于声明对象，但是作用域为局部。</li><li>iterable类型<br>为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型，具有iterable类型的集合可以通过新的for … of循环来遍历。</li><li>解构赋值</li><li>箭头函数</li><li>类</li></ol><p>es6 比 es5 增加了很多特殊的方法，如果你遇到了这些特殊的方法，你就可以确定它是 es6。<br>如果你的代码中没有引用这些特殊的方法，那我们就可以认为他是 es5 的。<br>所以前提你需要了解 es6 的语法才能做判断，高频使用的特性有箭头函数、解构赋值、let、const。</p><p>es5的继承是通过原型或者是构造函数机制来实现，es6用过class关键字定义类，里面有构造方法，类之间通过extends关键字实现，<br>子类必须在constructor方法中调用super方法</p><p>let和const有了块级作用域，变量声明不会提升相比于var</p><p><strong>es6generator:</strong><br>加粗样式generator函数就是一个封装的异步任务，也就是异步任务的容器，执行 Generator 函数会返回一个遍历器对象,async函数的实现，就是将Generator函数和自动执行器，包装在一个函数里<br><strong>ES6 和node的commonjs模块化规范的区别。</strong><br>es6是js的增强版，是js的语法规范，commonjs都只是为了解决js文件之间的依赖和引用问题，所以是一种js的包管理规范，其中的代表是Node遵循commonjs规范<br><strong>箭头函数，以及他们的this。</strong><br>所谓的箭头函数是在写法上面很简便和之前相比，类似于:(a,b)=&gt;{return a+b;}，箭头函数的this默认指向在定义它时,它所处的对象,而不是执行时的对象, 定义它的时候,可能环境是window（即继承父级的this）</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;es6–ES6特性&quot;&gt;&lt;a href=&quot;#es6–ES6特性&quot; class=&quot;headerlink&quot; title=&quot;es6–ES6特性&quot;&gt;&lt;/a&gt;es6–ES6特性&lt;/h2&gt;</summary>
    
    
    
    <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
    <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6--promise</title>
    <link href="http://yoursite.com/2020/08/25/promise/"/>
    <id>http://yoursite.com/2020/08/25/promise/</id>
    <published>2020-08-25T12:39:53.799Z</published>
    <updated>2020-08-25T12:49:03.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="es6–promise"><a href="#es6–promise" class="headerlink" title="es6–promise"></a>es6–promise</h2><a id="more"></a><p>promise是一个异步函数，主要是为了解决异步处理回调地狱(也就是循环嵌套的问题)而产生的，有3种状态，Fulfilled 为成功的状态，Rejected 为失败的状态，Pending 既不是 Fulfilld 也不是 Rejected 的状态，可以理解为 Promise 对象实例创建时候的初始状态<br>参考 <a href="https://www.jianshu.com/p/063f7e490e9a">https://www.jianshu.com/p/063f7e490e9a</a><br>     <a href="https://www.jianshu.com/p/1b63a13c2701">https://www.jianshu.com/p/1b63a13c2701</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line"> if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line"> resolve(value);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> reject(error);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line"> &#x2F;&#x2F; success</span><br><span class="line">&#125;, function(value) &#123;</span><br><span class="line"> &#x2F;&#x2F; failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;es6–promise&quot;&gt;&lt;a href=&quot;#es6–promise&quot; class=&quot;headerlink&quot; title=&quot;es6–promise&quot;&gt;&lt;/a&gt;es6–promise&lt;/h2&gt;</summary>
    
    
    
    <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
    <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
</feed>
