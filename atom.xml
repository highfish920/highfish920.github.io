<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>highfish920的博客</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-26T08:57:00.553Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>highfish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么TCP连接需要三次握手，为什么TCP连接需要三次握手四次挥手，TCP的三次握手和四次挥手绘图（画写ACK和SEQ的值），TCP与UDP的区别，Get和Post的区别？什么情况下用到，HTTP2 / HTTP1  之间的区别，websocket，HTTP Response的Header里面都有什么</title>
    <link href="http://yoursite.com/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/"/>
    <id>http://yoursite.com/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2/</id>
    <published>2020-08-26T08:30:14.722Z</published>
    <updated>2020-08-26T08:57:00.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么TCP连接需要三次握手"><a href="#为什么TCP连接需要三次握手" class="headerlink" title="为什么TCP连接需要三次握手"></a>为什么TCP连接需要三次握手</h2><a id="more"></a><p>三次握手为了确认客户端跟服务器都能接受到对方的信息,两次的话服务器不能确认客户端能否接收自己发的包<hr>第一次握手，客户端给服务器发包。 此时服务器确认自己可以接收客户端的包，客户端不确认服务器是否接收到了自己发的包<hr>第二次握手，服务器端回复客户端。 此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包<hr>第三次握手，客户端回复服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的包。两边都没有问题，开始通信<hr>简单概括：第一次：服务端和客户端建立联系；第二次：服务器端回复客户端；第三次：客户端回复服务器</p><h2 id="为什么TCP连接需要三次握手四次挥手"><a href="#为什么TCP连接需要三次握手四次挥手" class="headerlink" title="为什么TCP连接需要三次握手四次挥手"></a>为什么TCP连接需要三次握手四次挥手</h2><p><strong>为什么是三次握手？</strong><br>为了防止已失效的连接请求报文段突然有送到了服务器，因而产生错误,假设两次握手时，客户发出的第一个请求连接报文段在某一网络节点长时间滞留，以致延误到连接释放后才到达服务器。服务器收到失效的连接请求报文段后，认为是客户又发出一次新的连接请求。于是向客户发送确认报文段，同意建立连接，此时在假定两次握手的前提下，连接建立成功。这样会导致服务器的资源白白浪费<hr><br><strong>为什么是四次挥手？</strong><br>TCP协议是全双工通信，这意味着客户端和服务器端都可以向彼此发送数据，所以关闭连接是双方都需要确认的共同行为，假设是三次挥手时，首先释放了客户到服务器方向的连接，此时TCP连接处于半关闭状态，这时客户不能向服务器发送数据，而服务器还是可以向客户发送数据。如果此时客户收到了服务器的确认报文段后，就立即发送一个确认报文段，这会导致服务器向客户还在发送数据时连接就被关闭。这样会导致客户没有完整收到服务器所发的报文段</p><h2 id="TCP的三次握手和四次挥手绘图（画写ACK和SEQ的值）"><a href="#TCP的三次握手和四次挥手绘图（画写ACK和SEQ的值）" class="headerlink" title="TCP的三次握手和四次挥手绘图（画写ACK和SEQ的值）"></a>TCP的三次握手和四次挥手绘图（画写ACK和SEQ的值）</h2><p>所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。由客户端执行connect()触发<br> <img src="https://img-blog.csdnimg.cn/20200826163516943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。由客户端或服务端任一方执行close来触发<br> <img src="https://img-blog.csdnimg.cn/20200826163525911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议<br>UDP(User Datagram Protocol用户数据报协议）是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务<br>TCP 是面向连接的传输控制协议，而UDP提供了无链接的数据报服务//类似电话与短信<br>TCP 面向连接，提供可靠的数据服务<br>TCP首部开销20字节,UDP首部开销8字节<br>TCP逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道<br>UDP没有拥塞机制，因此网络出现拥堵不会使源主机的发送效率降低（有利于实时会议视频等）<br>TCP的连接只能是点到点的,UDP支持一对一，多对一，多对多的交互通信</p><h2 id="Get和Post的区别？什么情况下用到"><a href="#Get和Post的区别？什么情况下用到" class="headerlink" title="Get和Post的区别？什么情况下用到"></a>Get和Post的区别？什么情况下用到</h2><p>1    GET使用URL或Cookie传参。而POST将数据放在BODY中<br>2    GET的URL会有长度上的限制，则POST的数据则可以非常大<br>3    POST比GET安全，因为数据在地址栏上不可见<br><strong>最本质的区别</strong><br>Get是用来从服务器上获得数据，而post是用来向服务器上传递数据<br><strong>若符合下列任一情况，则用post方法：</strong><br>a    请求的结果有持续性的作用，例如：数据库内添加新的数据行<br>b    若使用get方法，则表单上收集的数据可能让URL过长<br>c    要传送的数据不是采用ASCII编码<br><strong>若符合下列任一情况，则用get方法：</strong><br>a    请求是为了查找资源，html表单数据仅用来搜索<br>b    请求结果无持续性的副作用<br>c    收集的数据及html表单内的输入字段名称的总长不超过1024个字符</p><h2 id="HTTP2-HTTP1-之间的区别"><a href="#HTTP2-HTTP1-之间的区别" class="headerlink" title="HTTP2 / HTTP1  之间的区别"></a>HTTP2 / HTTP1  之间的区别</h2><p>1    http2采用二进制格式而非文本格式，比起文本格式，二进制格式解析起来更加高效，并且错误少<br>2    http2是完全的多路复用，非有序并阻塞的—-只需要一个连接即可实现并行，多路复用的意思是它能同时处理多个消息的请求和响应，http1是一个连接一次只能提交一个请求的效率比较高，多了就会变慢<br>3    使用报头压缩，http2降低了开销，http1的消息头很大冗余,http2是将消息头中的不同的部分分别用不用的索引进行表示，且会用哈夫曼编码压缩字符串，最后封装成frame<br>4    http2让服务器可以将响应主动”推送”到客户端缓存中，HTTP2中服务器会主动将资源推送给客户端，例如把js和css文件主动推送给客户端而不用客户端解析HTML后请求再响应</p><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>websocket是一种网络通信协议，是HTML5开始提供的一种在单个TCP连接上进行全双工通信的协议，这个对比着http协议来说，http协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。http协议无法实现服务器主动向客户端发起消息，Websocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个webSocket对象</span><br><span class="line">var ws &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;localhost:9998&#x2F;echo&#39;);</span><br><span class="line">&#x2F;&#x2F; 建立webSocket连接成功触发事件</span><br><span class="line">ws.onopen &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F;使用send方法接收数据</span><br><span class="line">    ws.send(&#39;发送数据&#39;)</span><br><span class="line">    alert(&#39;数据发送中&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 接收服务端数据时触发事件</span><br><span class="line">ws.onmessage &#x3D; function (evt) &#123;</span><br><span class="line">    var received_msg &#x3D; evt.data</span><br><span class="line">    alert(&#39;数据已接收&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;断开webSocket连接成功触发事件</span><br><span class="line">ws.onclose &#x3D; function () &#123;</span><br><span class="line">    alert(&#39;数据已关闭&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP-Response的Header-里面都有什么"><a href="#HTTP-Response的Header-里面都有什么" class="headerlink" title="HTTP Response的Header 里面都有什么"></a>HTTP Response的Header 里面都有什么</h2><p>1    Cache-Control：告诉所有的缓存机制是否可以缓存及哪种类型<br>2    Content-Length：响应体的长度<br>3    Content-Type：返回内容的MIME类型，所谓的MIME就是解析的是什么，比方说：jpg就是图片<br>4    Expires：响应过期的日期和时间<br>5    Set-Cookie：设置Http Cookie</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么TCP连接需要三次握手&quot;&gt;&lt;a href=&quot;#为什么TCP连接需要三次握手&quot; class=&quot;headerlink&quot; title=&quot;为什么TCP连接需要三次握手&quot;&gt;&lt;/a&gt;为什么TCP连接需要三次握手&lt;/h2&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议头包含哪些重要部分，HTTP状态码。网络url输入到输出都做了什么，为什么说性能优化就要减少HTTP的访问次数，HTTP的请求过程与原理，HTTP的请求过程与原理，TLS的中文名？TLS在那一网络层，TCP连接的特点，TCP连接如何保证安全可靠</title>
    <link href="http://yoursite.com/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"/>
    <id>http://yoursite.com/2020/08/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/</id>
    <published>2020-08-26T08:28:14.957Z</published>
    <updated>2020-08-26T08:56:44.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP协议头包含哪些重要部分，HTTP状态码。"><a href="#HTTP协议头包含哪些重要部分，HTTP状态码。" class="headerlink" title="HTTP协议头包含哪些重要部分，HTTP状态码。"></a>HTTP协议头包含哪些重要部分，HTTP状态码。</h2><a id="more"></a><p>HTTP协议头包括通用头，请求头，响应头和实体头四个部分<br>200    请求已成功，请求所希望的响应头或数据体将随此响应返回<br>302    Moved Permanently（重定向）请求的URL已移走。Response中应该包含一个Location URL, 说明资源现在所处的位置<br>304    Not Modified（未修改）客户的缓存资源是最新的， 要客户端使用缓存<br>404    Not Found 未找到资源，可能是路径方面的错误<br>503    服务器目前无法为请求提供服务，但过一段时间就可以恢复服务</p><h2 id="网络url输入到输出都做了什么"><a href="#网络url输入到输出都做了什么" class="headerlink" title="网络url输入到输出都做了什么"></a>网络url输入到输出都做了什么</h2><p>1    当我们输入一个域名像：<a href="http://www.baidu.com/">www.baidu.com</a> </p><p>2    浏览器查找浏览器缓存，如果有域名的IP地址则返回，如果没有继续查找<br>3    系统查找系统缓存，如果有域名的IP地址则返回，如果没有继续查找<br>4    路由器查找路由器缓存，如果有域名的IP地址则返回，如果没有继续查找<br>5    本地域名服务器采用迭代查询，它先向一个根域名服务器查询<br>6    根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.com的IP地址<br>7    本地域名服务器向顶级域名服务器dns.com进行查询<br>8    顶级域名服务器dns.com告诉本地域名服务器，下一次应查询的权限域名服务器dns.baidu.com的IP地址<br>9    本地域名服务器向权限域名服务器dns.baidu.com进行查询<br>10    权限域名服务器dns.baidu.com告诉本地域名服务器，所查询的主机<a href="http://www.baidu.com的ip地址/">www.baidu.com的IP地址</a><br>11    本地域名服务器最后把查询结果告诉主机<br>12    主机浏览器获取到Web服务器的IP地址后，与服务器建立TCP连接<br>13    浏览器所在的客户机向服务器发出连接请求报文<br>14    服务器接收报文后，同意建立连接，向客户机发出确认报文<br>15    客户机接收到确认报文后，再次向服务器发出报文，确认已接收到确认报文<br>16    此处客户机与服务器之间的TCP连接建立完成，开始通信<br>17    浏览器发出取文件命令：GET<br>18    服务器给出响应，将指定文件发送给浏览器<br>19    浏览器释放TCP连接<br>20    浏览器所在主机向服务器发出连接释放报文，然后停止发送数据<br>21    服务器接收到释放报文后发出确认报文，然后将服务器上未传送完的数据发送完<br>22    服务器数据传输完毕后，向客户机发送连接释放报文<br>23    客户机接收到报文后，发出确认，然后等待一段时间后，释放TCP连接<br>24    浏览器显示页面中所有文本</p><h2 id="为什么说性能优化就要减少HTTP的访问次数"><a href="#为什么说性能优化就要减少HTTP的访问次数" class="headerlink" title="为什么说性能优化就要减少HTTP的访问次数"></a>为什么说性能优化就要减少HTTP的访问次数</h2><p>1    http请求头的数据量：每次请求都会带上一些额外的信息进行传输,所以请求越多的时候，在网络上传输的数据就会变多了，速度就变慢了<br>2    http连接的开销：从用户输入URL到看到页面，经过一系列的解析和连接，以及等待</p><h2 id="HTTP的请求过程与原理"><a href="#HTTP的请求过程与原理" class="headerlink" title="HTTP的请求过程与原理"></a>HTTP的请求过程与原理</h2><p><strong>http请求的过程：</strong> 域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt;服务器响应http请求，浏览器得到html代码 –&gt;浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户<br><strong>请求原理：</strong> HTTP协议是应用层的一种协议，是一种C/S架构服务，基于TCP/IP协议来通信，监听在TCP的80端口上，HTTP协议实现的是客户端可以向服务端获得web资源</p><h2 id="https有几次握手和挥手，https的原理"><a href="#https有几次握手和挥手，https的原理" class="headerlink" title="https有几次握手和挥手，https的原理"></a>https有几次握手和挥手，https的原理</h2><p>https是3次握手和4次挥手，和http是一样的。<br>原理：https在传输数据前需要客户端(浏览器)与服务器(网站)之间进行一次握手,在握手过程中将确立双方加密传输数据的密码信息.TLS/SSL协议是一套加密传输协议,使用了非对称加密,对称加密,以及HASH算法</p><h2 id="TLS的中文名？TLS在那一网络层"><a href="#TLS的中文名？TLS在那一网络层" class="headerlink" title="TLS的中文名？TLS在那一网络层"></a>TLS的中文名？TLS在那一网络层</h2><p>TLS的中文名是：安全传输层协议，在传输层。</p><h2 id="TCP连接的特点，TCP连接如何保证安全可靠"><a href="#TCP连接的特点，TCP连接如何保证安全可靠" class="headerlink" title="TCP连接的特点，TCP连接如何保证安全可靠"></a>TCP连接的特点，TCP连接如何保证安全可靠</h2><p>TCP的可靠性是通过顺序编号和确认（ACK）来实现的，TCP的接收端必须丢弃重复的数据，并且TCP提供流量控制，连接的每一个地方都有固定大小的缓冲空间。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;HTTP协议头包含哪些重要部分，HTTP状态码。&quot;&gt;&lt;a href=&quot;#HTTP协议头包含哪些重要部分，HTTP状态码。&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议头包含哪些重要部分，HTTP状态码。&quot;&gt;&lt;/a&gt;HTTP协议头包含哪些重要部分，HTTP状态码。&lt;/h2&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>es6--Promise如何封装一个AJAX</title>
    <link href="http://yoursite.com/2020/08/25/Promise%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAAJAX/"/>
    <id>http://yoursite.com/2020/08/25/Promise%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAAJAX/</id>
    <published>2020-08-25T12:54:51.531Z</published>
    <updated>2020-08-25T13:17:17.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="es6–promise"><a href="#es6–promise" class="headerlink" title="es6–promise"></a>es6–promise</h2><a id="more"></a><p>　Promise的出现主要是解决地狱回调的问题，比如你需要结果需要请求很多个接口，这些接口的参数需要另外那个的接口返回的数据作为依赖，这样就需要我们一层嵌套一层，但是有了Promise 我们就无需嵌套<br>　参考：<a href="https://www.cnblogs.com/elexmiumiu/p/12196122.html">https://www.cnblogs.com/elexmiumiu/p/12196122.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">function ajax(optionsOverride)&#123;</span><br><span class="line">    &#x2F;&#x2F;将传入的参数与默认的合并</span><br><span class="line">    var options &#x3D; &#123;&#125;</span><br><span class="line">    for(var k in ajaxOptions)&#123;</span><br><span class="line">        options[k] &#x3D; optionsOverride[k] || ajaxOptions[k]</span><br><span class="line">    &#125;</span><br><span class="line">    options.async &#x3D; options.async &#x3D;&#x3D;&#x3D; false ? false : true</span><br><span class="line">    var xhr &#x3D; options.xhr &#x3D; options.xhr || new XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">    return new Promise(function(resolve,reject)&#123;</span><br><span class="line">        xhr.open(options.method,options.url,options.async)</span><br><span class="line">        xhr.timeout &#x3D; options.timeout</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;设置请求头</span><br><span class="line">        for(var k in options.headers)&#123;</span><br><span class="line">            xhr.setRuquestHeader(k,options,headers[k])</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;注册xhr对象事件</span><br><span class="line">        xhr.onprogress &#x3D; options.onprogress</span><br><span class="line">        xhr.onload.onprogress &#x3D; options.onploadprogress</span><br><span class="line">        xhr.responseType &#x3D; options.dataType</span><br><span class="line"></span><br><span class="line">        xhr.onabort &#x3D; function()&#123;</span><br><span class="line">            reject(new Error(&#123;</span><br><span class="line">                errorType: &#39;abort_error&#39;,</span><br><span class="line">                xhr:xhr</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xhr.ontimeout &#x3D; function()&#123;</span><br><span class="line">            reject(&#123;</span><br><span class="line">                errorType: &#39;timeout_error&#39;,</span><br><span class="line">                xhr:xhr</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        xhr.onerror &#x3D; function()&#123;</span><br><span class="line">            reject(&#123;</span><br><span class="line">                errorType: &#39;onerror&#39;,</span><br><span class="line">                xhr:xhr</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xhr.onloadend &#x3D; function()&#123;</span><br><span class="line">            if ((xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status&lt; 300) || xhr.status &#x3D;&#x3D; 304) &#123;</span><br><span class="line">                resolve(xhr)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                reject(&#123;</span><br><span class="line">                    errorType: &#39;status_error&#39;,</span><br><span class="line">                    xhr:xhr</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                xhr.send(options.data)</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                reject(&#123;</span><br><span class="line">                    errorType: &#39;send_error&#39;,</span><br><span class="line">                    error:e</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;es6–promise&quot;&gt;&lt;a href=&quot;#es6–promise&quot; class=&quot;headerlink&quot; title=&quot;es6–promise&quot;&gt;&lt;/a&gt;es6–promise&lt;/h2&gt;</summary>
    
    
    
    <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
    <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6--ES6特性</title>
    <link href="http://yoursite.com/2020/08/25/ES6%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2020/08/25/ES6%E7%89%B9%E6%80%A7/</id>
    <published>2020-08-25T12:49:29.786Z</published>
    <updated>2020-08-26T09:15:54.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="es6–ES6特性"><a href="#es6–ES6特性" class="headerlink" title="es6–ES6特性"></a>es6–ES6特性</h2><a id="more"></a><p><strong>常用的es6新特性：</strong></p><ol><li>let &amp;&amp; const<br>let命令也用于声明对象，但是作用域为局部。</li><li>iterable类型<br>为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型，具有iterable类型的集合可以通过新的for … of循环来遍历。</li><li>解构赋值</li><li>箭头函数</li><li>类</li></ol><p>es6 比 es5 增加了很多特殊的方法，如果你遇到了这些特殊的方法，你就可以确定它是 es6。<br>如果你的代码中没有引用这些特殊的方法，那我们就可以认为他是 es5 的。<br>所以前提你需要了解 es6 的语法才能做判断，高频使用的特性有箭头函数、解构赋值、let、const。</p><p>es5的继承是通过原型或者是构造函数机制来实现，es6用过class关键字定义类，里面有构造方法，类之间通过extends关键字实现，<br>子类必须在constructor方法中调用super方法</p><p>let和const有了块级作用域，变量声明不会提升相比于var</p><p><strong>es6generator:</strong><br>加粗样式generator函数就是一个封装的异步任务，也就是异步任务的容器，执行 Generator 函数会返回一个遍历器对象,async函数的实现，就是将Generator函数和自动执行器，包装在一个函数里<br><strong>ES6 和node的commonjs模块化规范的区别。</strong><br>es6是js的增强版，是js的语法规范，commonjs都只是为了解决js文件之间的依赖和引用问题，所以是一种js的包管理规范，其中的代表是Node遵循commonjs规范<br><strong>箭头函数，以及他们的this。</strong><br>所谓的箭头函数是在写法上面很简便和之前相比，类似于:(a,b)=&gt;{return a+b;}，箭头函数的this默认指向在定义它时,它所处的对象,而不是执行时的对象, 定义它的时候,可能环境是window（即继承父级的this）</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;es6–ES6特性&quot;&gt;&lt;a href=&quot;#es6–ES6特性&quot; class=&quot;headerlink&quot; title=&quot;es6–ES6特性&quot;&gt;&lt;/a&gt;es6–ES6特性&lt;/h2&gt;</summary>
    
    
    
    <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
    <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6--promise</title>
    <link href="http://yoursite.com/2020/08/25/promise/"/>
    <id>http://yoursite.com/2020/08/25/promise/</id>
    <published>2020-08-25T12:39:53.799Z</published>
    <updated>2020-08-25T12:49:03.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="es6–promise"><a href="#es6–promise" class="headerlink" title="es6–promise"></a>es6–promise</h2><a id="more"></a><p>promise是一个异步函数，主要是为了解决异步处理回调地狱(也就是循环嵌套的问题)而产生的，有3种状态，Fulfilled 为成功的状态，Rejected 为失败的状态，Pending 既不是 Fulfilld 也不是 Rejected 的状态，可以理解为 Promise 对象实例创建时候的初始状态<br>参考 <a href="https://www.jianshu.com/p/063f7e490e9a">https://www.jianshu.com/p/063f7e490e9a</a><br>     <a href="https://www.jianshu.com/p/1b63a13c2701">https://www.jianshu.com/p/1b63a13c2701</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line"> if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line"> resolve(value);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line"> reject(error);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function(value) &#123;</span><br><span class="line"> &#x2F;&#x2F; success</span><br><span class="line">&#125;, function(value) &#123;</span><br><span class="line"> &#x2F;&#x2F; failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;es6–promise&quot;&gt;&lt;a href=&quot;#es6–promise&quot; class=&quot;headerlink&quot; title=&quot;es6–promise&quot;&gt;&lt;/a&gt;es6–promise&lt;/h2&gt;</summary>
    
    
    
    <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
    <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>cookie如何设置或获取，setTimeout和promise的执行顺序，javaScript的事件流模型，navigator对象，location和history，js的垃圾回收机制，内存泄漏的原因和场景，Dom事件中的target和currentTarget有什么区别，Typeof和instanceof</title>
    <link href="http://yoursite.com/2020/08/24/js%E9%9D%A2%E8%AF%955/"/>
    <id>http://yoursite.com/2020/08/24/js%E9%9D%A2%E8%AF%955/</id>
    <published>2020-08-24T10:05:33.284Z</published>
    <updated>2020-08-24T13:06:40.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cookie如何设置或获取"><a href="#cookie如何设置或获取" class="headerlink" title="cookie如何设置或获取"></a>cookie如何设置或获取</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;1.设置cookie</span><br><span class="line">    function setCookie(cname, cvalue, exdays) &#123;</span><br><span class="line">        var d &#x3D; new Date()</span><br><span class="line">        d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000))</span><br><span class="line">        var expires &#x3D; &quot;expires&#x3D;&quot; + d.toGMTString();</span><br><span class="line">        document.cookie &#x3D; cname + &quot;&#x3D;&quot; + cvalue + &quot;;&quot; + expires</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;2.获取cookie</span><br><span class="line">    function getCookie(cname) &#123;</span><br><span class="line">        var name &#x3D; cname + &quot;&#x3D;&quot;</span><br><span class="line">        var ca &#x3D; document.cookie.split(&#39;;&#39;)</span><br><span class="line">        for (var i &#x3D; 0; i &lt; ca.length; i++) &#123;</span><br><span class="line">            var c &#x3D; ca[i].trim();</span><br><span class="line">            if (c.indexOf(name) &#x3D;&#x3D; 0) return c.substring(name.length, c.length);</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="setTimeout和promise的执行顺序"><a href="#setTimeout和promise的执行顺序" class="headerlink" title="setTimeout和promise的执行顺序"></a>setTimeout和promise的执行顺序</h2><p>setTimeout有一个4ms的最短时间，也就是说不管你设定多少，反正最少都要间隔4ms才运行里面的回调，<br>从具体实现上来说，这俩的异步队列不一样，Promise所在的那个异步队列优先级要高一些</p><h2 id="javaScript的事件流模型"><a href="#javaScript的事件流模型" class="headerlink" title="javaScript的事件流模型"></a>javaScript的事件流模型</h2><p>捕获流：    在捕获模式的定义中，当事件发生时，该事件由高层次向低层次传递<br>冒泡流：    在冒泡流的定义中，当事件发生时，该事件由低层次向高层次传播（像是水泡向上冒出）<br>DOM中的事件流：    当事件发生时，事件由捕获过程-&gt;冒泡过程，即由捕获阶段-&gt;处于目标对象阶段-&gt;冒泡阶段组成</p><h2 id="navigator对象，location和history"><a href="#navigator对象，location和history" class="headerlink" title="navigator对象，location和history"></a>navigator对象，location和history</h2><p>Navigator对象<br>1    History 对象包含用户（在浏览器窗口中）访问过的 URL。<br>2    History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。<br>Navigator对象方法<br>1    Back():加载history列表中的前一个URL<br>2    Forward():加载history列表中的下一个URL<br>3    Go():加载 history 列表中的某个具体页面。<br>Location对象<br>1    Location 对象包含有关当前 URL 的信息。<br>2    Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。<br>Location对象方法<br>hash<br>设置或返回从井号 (#) 开始的 URL（锚）。<br>host<br>设置或返回主机名和当前 URL 的端口号。<br>hostname<br>设置或返回当前 URL 的主机名。<br>href<br>设置或返回完整的 URL。<br>pathname<br>设置或返回当前 URL 的路径部分。<br>port<br>设置或返回当前 URL 的端口号。<br>protocol<br>设置或返回当前 URL 的协议。<br>search<br>设置或返回从问号 (?) 开始的 URL（查询部分）。<br>assign()<br>加载新的文档。<br>reload()<br>重新加载当前文档。<br>replace()<br>用新的文档替换当前文档。</p><h2 id="js的垃圾回收机制"><a href="#js的垃圾回收机制" class="headerlink" title="js的垃圾回收机制"></a>js的垃圾回收机制</h2><p>javascript具有自动垃圾回收机制，执行环境会负责管理代码执行过程中使用的内存。原理就是找出那些不再继续使用的变量，然后释放其占有内存</p><h2 id="内存泄漏的原因和场景"><a href="#内存泄漏的原因和场景" class="headerlink" title="内存泄漏的原因和场景"></a>内存泄漏的原因和场景</h2><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。<br>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。<br>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）</p><h2 id="Dom事件中的target和currentTarget有什么区别"><a href="#Dom事件中的target和currentTarget有什么区别" class="headerlink" title="Dom事件中的target和currentTarget有什么区别"></a>Dom事件中的target和currentTarget有什么区别</h2><p>target在事件流的目标阶段；currentTarget在事件流的捕获，目标及冒泡阶段。只有当事件流处在目标阶段的时候，两个的指向才是一样的， 而当处于捕获和冒泡阶段的时候，target指向被单击的对象而currentTarget指向当前事件活动的对象(注册该事件的对象)（一般为父级）</p><h2 id="Typeof和instanceof"><a href="#Typeof和instanceof" class="headerlink" title="Typeof和instanceof"></a>Typeof和instanceof</h2><p>Typeof:    typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。<br>它返回值是一个字符串，该字符串说明运算数的类型<br>instanceof    用于判断一个变量是否某个对象的实例<br>原理：nstanceof 检测一个对象A是不是另一个对象B的实例的原理是：查看对象B的prototype指向的对象是否在对象A的[[prototype]]链上。如果在，则返回true,如果不在则返回false。不过有一个特殊的情况，当对象B的prototype为null将会报错(类似于空指针异常)</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;cookie如何设置或获取&quot;&gt;&lt;a href=&quot;#cookie如何设置或获取&quot; class=&quot;headerlink&quot; title=&quot;cookie如何设置或获取&quot;&gt;&lt;/a&gt;cookie如何设置或获取&lt;/h2&gt;</summary>
    
    
    
    <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
    <category term="js基础" scheme="http://yoursite.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JS动画和CSS3动画有什么区别,倒计时,JS处理异常的语句有哪些举例说明,JS的设计模式,轮播图组件开发，我有10000万张图片要轮播，websocket,手指点击触控屏幕是什么事件，函数柯里化是什么,JS代码调试</title>
    <link href="http://yoursite.com/2020/08/24/js%E9%9D%A2%E8%AF%956/"/>
    <id>http://yoursite.com/2020/08/24/js%E9%9D%A2%E8%AF%956/</id>
    <published>2020-08-24T10:05:33.270Z</published>
    <updated>2020-08-26T09:13:33.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS动画和CSS3动画有什么区别"><a href="#JS动画和CSS3动画有什么区别" class="headerlink" title="JS动画和CSS3动画有什么区别"></a>JS动画和CSS3动画有什么区别</h2><a id="more"></a><p>功能涵盖面，JS比CSS3大定义动画过程的@keyframes不支持递归定义，如果有多种类似的动画过程，需要调节多个参数来生成的话，将会有很大的冗余（比如jQuery Mobile的动画方案），而JS则天然可以以一套函数实现多个不同的动画过程时间尺度上，@keyframes的动画粒度粗，而JS的动画粒度控制可以很细<br>CSS3动画里被支持的时间函数非常少，不够灵活以现有的接口，CSS3动画无法做到支持两个以上的状态转化<br>实现/重构难度不一，CSS3比JS更简单，性能调优方向固定对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件CSS3有兼容性问题，而JS大多时候没有兼容性问题</p><h1 id="倒计时"><a href="#倒计时" class="headerlink" title="倒计时"></a>倒计时</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;time&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var time &#x3D;   document.querySelector(&quot;#time&quot;)</span><br><span class="line">      var d &#x3D; 6;</span><br><span class="line">      function setTime()&#123;</span><br><span class="line">          d--;</span><br><span class="line">          time.innerHTML&#x3D;&quot;时间：&quot;+d</span><br><span class="line">          if(d&#x3D;&#x3D;0)&#123;</span><br><span class="line">              return  time.innerHTML&#x3D;&#39;结束&#39;</span><br><span class="line">          &#125;</span><br><span class="line">          setTimeout(&#39;setTime()&#39;,1000)</span><br><span class="line">      &#125;</span><br><span class="line">      setTime()</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h2 id="JS处理异常的语句有哪些举例说明"><a href="#JS处理异常的语句有哪些举例说明" class="headerlink" title="JS处理异常的语句有哪些举例说明"></a>JS处理异常的语句有哪些举例说明</h2><p>Javascript的异常捕获机制<br>1    try…catch语句<br>try{ console.log(b); console.log(“我不会输出的，不要找了”) }catch(error){ console.log(“发生错误了”) } console.log(“我try catch后面的代码”)<br>2    finally语句<br>try{ console.log(b); console.log(“我不会输出的，不要找了”) }catch(error){ console.log(“发生错误了”) }finally { console.log(“不管发生不发生错误，我都会执行”) } console.log(“我try catch后面的代码”)</p><h2 id="JS的设计模式"><a href="#JS的设计模式" class="headerlink" title="JS的设计模式"></a>JS的设计模式</h2><p>1    工厂模式<br>优点    能解决多个相似的问题<br>缺点    不能知道对象识别的问题(对象的类型不知道)<br>2    单体模式<br>单体模式是一个用来划分命名空间并将一批属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次<br>单体模式的优点是：<br>1    可以用来划分命名空间，减少全局变量的数量<br>2    使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护<br>3    可以被实例化，且实例化一次<br>3    模块模式<br> 模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，先定义了私有变量和函数，供内部函数使用，然后将一个对象字面量作为函数的值返回，返回的对象字面量中只包含可以公开的属性和方法。这样的话，可以提供外部使用该方法；由于该返回对象中的公有方法是在匿名函数内部定义的，因此它可以访问内部的私有变量和函数<br>我们什么时候使用模块模式？<br>如果我们必须创建一个对象并以某些数据进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么我们这个时候就可以使用模块模式了<br>4    代理模式<br>代理的优点：<br>1    代理对象可以代替本体被实例化，并使其可以被远程访问；<br>2    它还可以把本体实例化推迟到真正需要的时候；对于实例化比较费时的本体对象，或者因为尺寸比较大以至于不用时不适于保存在内存中的本体，我们可以推迟实例化该对象</p><h1 id="轮播图组件开发，我有10000万张图片要轮播"><a href="#轮播图组件开发，我有10000万张图片要轮播" class="headerlink" title="轮播图组件开发，我有10000万张图片要轮播"></a>轮播图组件开发，我有10000万张图片要轮播</h1><p>首先让一组图片绝对定位，让其重叠在一起，然后通过一个函数来控制图片的透明度变化。同时还有一个定时器，不停的触发这个函数，每次改变不同图片的透明度，让其显示。（更简单的效果是直接修改display属性，让该显示的图片display:block,而不显示的设为display:none就可以，只是效果上会差一些，但原理相同）<br>1    图片切换函数。接受一个参数，表示滚动方向。调用缓动函数切换图片。调用切换按钮图标函数点亮相应的按钮<br>2    缓动函数<br>3    点亮按钮函数<br>4    初始化函数。用于绑定事件，创建按钮和箭头，初始化最初位置<br>5    创建箭头函数<br>6    创建按钮函数<br>7    开始轮播函数<br>8    轮播函数<br>9    停止函数。用于停止轮播<br>还有一些公用方法：$()：选择DOM元素。addClass(ele,”className”)：给元素添加类名。removeClass(ele,”className”)移除元素的类名。$.add(ele,”type”,fun)：给一个DOM节点绑定事件。getCSS(ele,”prop”)：获取元素相应属性的值。$.delegateTag(“selector”,”tagName”,”type”,fun)：事件代理。</p><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/Client Agent都能主动的向对方发送或接收数据，就像Socket一样；WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信</p><h2 id="手指点击触控屏幕是什么事件，函数柯里化是什么"><a href="#手指点击触控屏幕是什么事件，函数柯里化是什么" class="headerlink" title="手指点击触控屏幕是什么事件，函数柯里化是什么"></a>手指点击触控屏幕是什么事件，函数柯里化是什么</h2><p>手指点击称为：touch事件；<br>什么是函数柯里化：<br>柯里化是一个转换过程，把接受多个参数的函数变换成接受一个单一参数(译注：最初函数的第一个参数)的函数，如果其他的参数是必要的，返回接受余下的参数且返回结果的新函数<br>柯理化函数思想：一个js预先处理的思想；利用函数执行可以形成一个不销毁的作用域的原理，把需要预先处理的内容都储存在这个不销毁的作用域中，并且返回一个小函数，以后我们执行的都是小函数，在小函数中把之前预先存储的值进行相关的操作处理即可；<br>bind方法的作用：把传递进来的callback回调方法中的this预先处理为上下文context;</p><h2 id="JS代码调试"><a href="#JS代码调试" class="headerlink" title="JS代码调试"></a>JS代码调试</h2><p>1    可以在JavaScript代码中加入一句debugger;来手工造成一个断点效果。<br>需要带有条件的断点吗？你只需要用if语句包围它<br>2    设置在DOM node发生变化时触发断点，谷歌浏览器的开发工具里有一个超级好用的功能，专门可以对付这种情况，叫做“Break on…”，你在DOM节点上右键，就能看到这个菜单项。断点的触发条件可以设置成这个节点被删除、节点的属性有任何变化，或它的某个子节点有变化发生<br>3    Ajax 断点：XHR断点，或Ajax断点，就像它们的名字一样，可以让我们设置一个断点，在特点的Ajax调用发生时触发它们。<br>当你在调试Web应用的网络传输时，这一招非常的有效<br>4    移动设备模拟环境：谷歌浏览器里有一些非常有趣的模拟移动设备的工具，帮助我们调试程序在移动设备里的运行情况。找到它的方法是：按F12，调出开发者工具，然后按ESC键(当前tab不能是Console)，你就会看到第二层调试窗口出现，里面的Emulation标签页里有各种模拟设备可选。当然，这不会就变成了真正的iPhone，只是模拟了iPhone的尺寸，触摸事件和浏览器User Agent值<br>5    使用Audits改进你的网站<br>YSlow是一个非常棒的工具。谷歌浏览器的开发者工具里也有一个非常类似的工具，叫Audits。<br>它可快速的审计你的网站，给你提出非常实际有效的优化你的网站的建议和方法</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JS动画和CSS3动画有什么区别&quot;&gt;&lt;a href=&quot;#JS动画和CSS3动画有什么区别&quot; class=&quot;headerlink&quot; title=&quot;JS动画和CSS3动画有什么区别&quot;&gt;&lt;/a&gt;JS动画和CSS3动画有什么区别&lt;/h2&gt;</summary>
    
    
    
    <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
    <category term="js基础" scheme="http://yoursite.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>窗口坐标，深拷贝与浅拷贝，可复用的事件监听方法，Js的字符串类型，正则表达式的函数使用</title>
    <link href="http://yoursite.com/2020/08/23/%E7%AA%97%E5%8F%A3%E5%9D%90%E6%A0%87%EF%BC%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95%EF%BC%8CJs%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/08/23/%E7%AA%97%E5%8F%A3%E5%9D%90%E6%A0%87%EF%BC%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%96%B9%E6%B3%95%EF%BC%8CJs%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</id>
    <published>2020-08-23T12:25:02.551Z</published>
    <updated>2020-08-24T13:02:54.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="窗口坐标"><a href="#窗口坐标" class="headerlink" title="窗口坐标"></a>窗口坐标</h2><a id="more"></a><p>1    clientHeight和clientWidth用于描述元素内尺寸，是指 元素内容+内边距 大小，不包括边框（IE下实际包括）、外边距、滚动条部分<hr><br>2    offsetHeight和offsetWidth用于描述元素外尺寸，是指 元素内容+内边距+边框，不包括外边距和滚动条部分<hr><br>3    clientTop和clientLeft返回内边距的边缘和边框的外边缘之间的水平和垂直距离，也就是左，上边框宽度<hr><br>4    offsetTop和offsetLeft表示该元素的左上角（边框外边缘）与已定位的父容器（offsetParent对象）左上角的距离<hr><br>5    offsetParent对象是指元素最近的定位（relative,absolute）祖先元素，递归上溯，如果没有祖先元素是定位的话，会返回null<hr><br>可以通过调用元素的getBoundingClientRect方法。方法返回一个有left、right、top、bottom属性的对象，分别表示元素四个位置的相对于视口的坐标。getBoundingClientRect所返回的坐标包含元素的内边距和边框，不包含外边距</p><h2 id="Js的字符串类型，正则表达式的函数怎么使用"><a href="#Js的字符串类型，正则表达式的函数怎么使用" class="headerlink" title="Js的字符串类型，正则表达式的函数怎么使用"></a>Js的字符串类型，正则表达式的函数怎么使用</h2><p>1    charCodeAt方法返回一个整数，代表指定位置字符的Unicode编码</p><hr>2    fromCharCode方法从一些Unicode字符串中返回一个字符串<hr>3    charAt方法返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串<hr>4    slice方法返回字符串的片段<hr>5    substring方法返回位于String对象中指定位置的子字符串<hr>6    substr方法返回一个从指定位置开始的指定长度的子字符串<hr>7    indexOf方法放回String对象内第一次出现子字符串位置。如果没有找到子字符串，则返回-1<hr>8    lastIndexOf方法返回String对象中字符串最后出现的位置。如果没有匹配到子字符串，则返回-1<hr>9    search方法返回与正则表达式查找内容匹配的第一个字符串的位置<hr>10    concat方法返回字符串值，该值包含了两个或多个提供的字符串的连接<hr>11    将一个字符串分割为子字符串，然后将结果作为字符串数组返回<hr>12    toLowerCase方法返回一个字符串，该字符串中的字母被转换成小写<hr>13    toUpperCase方法返回一个字符串，该字符串中的所有字母都被转换为大写字母<br><hr>**js正则表达式之replace函数用法：**功能：    replace函数返回根据正则表达式进行文字替换后的字符串的复制格式：    stringObj.replace(rgExp, replaceText) 参数：    字符串stringObj，rgExp正则表达式，replaceText所替换的内容 <br>**js正则表达式之test函数用法**功能介绍：该方法的返回值是布尔值，通过该值可以匹配字符串中是否存在于正则表达式相匹配的结果，如果有匹配内容，返回ture，如果没有匹配内容返回false，该方法常用于判断用户输入数据的合法性，比如检验Email的合法性<br><hr><p><strong>js正则表达式之match函数用法</strong></p><p>功能：    使用正则表达式模式对字符串执行查找，并将包含查找的结果作为数组返回<br>格式：    stringObj.match(rgExp) stringObj为字符串必选 rgExp为正则表达式必选项<br>返回值：    如果能匹配则返回结果数组，如果不能匹配返回null<br></p><hr><p><strong>js正则表达式之search方法讲解</strong><br>功能：    返回与正则表达式查找内容匹配的第一个子字符串的位置<br>语法：    stringObj.search(rgExp) stringObj 必选项 rgExp正则表达式<br>返回值：    search 方法指明是否存在相应的匹配。如果找到一个匹配，search方法将返回一个整数值，指明这个匹配距离字符串开始的偏移位置。如果没有找到匹配，则返回 -1 <br><hr></p><p><strong>js正则表达式之exec方法讲解</strong><br>功能说明：该函数通过对指定你的字符串进行一次匹配检测，获取字符串中的第一个与正则表达式的内容，并且将匹配的内容和子匹配的结果存放在返回数组中。<br>基本方法：objReg.exec(string) ，objReg，RegExp对象的名称 ，string，要进行匹配的字符串。</p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝不能完成需求，对于属性是对象的时候，只是进行简单的地址拷贝，其引用关系也在.<br><img src="https://img-blog.csdnimg.cn/20200823165929761.png#pic_center" alt="在这里插入图片描述"><br>深拷贝和浅拷贝的区别：是在对象状态中包含其它对象的引用的时候，当拷贝一个对象时，如果需要拷贝这个对象引用的对象，则是深拷贝，否则是浅拷贝。</p><p>对于浅拷贝和深拷贝的区别简单的说就是：浅复制会导致 obj 和 obj1 指向同一块内存地址，大概的示意图如下。而深复制一般都是开辟一块新的内存地址，将原对象的各个属性逐个复制出去。具体回答可参考<a href="https://www.zhihu.com/question/23031215">https://www.zhihu.com/question/23031215</a>  邹润阳的回答。 这里主要讲的是深拷贝整个函数是怎么实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: 10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;浅拷贝</span><br><span class="line">function copy(obj) &#123;</span><br><span class="line">    var newObj &#x3D; &#123;&#125;;</span><br><span class="line">    for (var attr in obj) &#123;</span><br><span class="line">        newObj[attr] &#x3D; obj[attr]</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;深拷贝</span><br><span class="line">function deepCopy(obj) &#123;</span><br><span class="line">    var newObj &#x3D; &#123;&#125;</span><br><span class="line">    if (typeof obj !&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">        return obj</span><br><span class="line">    &#125;</span><br><span class="line">    for (var attr in obj) &#123;</span><br><span class="line">        newObj[attr] &#x3D; deepCopy(obj[attr])</span><br><span class="line">    &#125;</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; deepCopy(obj1) &#x2F;&#x2F;第一层循环为 obj2 &#x3D; deep  第二层循环为 newObj[b] newObj[a] &#x3D; &#123;b:10&#125;</span><br><span class="line">alert(obj2.a.b) &#x2F;&#x2F;10</span><br><span class="line">alert(obj1.a.b) &#x2F;&#x2F;10</span><br></pre></td></tr></table></figure><p>主要是用了递归的思想：</p><p>obj2=deepCopy(obj1)—–&gt;调用deepCopy函数，传入的参数是obj1.第一个if判断是否是对象，如果是则执行下面的for/in循环，如果不是则返回obj。第一个obj1显然是对象，所以执行for/in循环。得到的结果是：</p><p>newObj[a]=deepCopy(obj1[a])=deepCopy({b:10})—–&gt;再次调用deepCopy函数，传入的参数是对象{b:10}，执行for/in循环。得到的结果是：<br>newObj[b]=deepCopy({b:10}[b])=deepCopy(10)——–&gt;再调用deepCopy函数，传入的参数是{10}，不是对象，返回obj，也就是10，得到的结果是：<br>newObj[b]=deepCopy({b:10}[b])=deepCopy(10)=10.<br>至此，整个“递”的过程就完成了。下面是“归”的过程。也就是一个相反的过程</p><p>deepCopy(10)=10.  代入上面的第二步，执行for/in循环得到newObj[b]=10，然后return newObj={b:10}<br>代入上面的第一步，执行for/in循环得到newObj[a]=deepCopy(obj1[a])=deepCopy({b:10})   deepCopy函数执行返回就是第一步的return newObj={b:10}，所以newObj[a]={b:10}，return newObj={a:{b:10}}<br> 在return newObj；上添加console.log(newObj);输出结果如下：<br> <img src="https://img-blog.csdnimg.cn/20200823172556868.png#pic_center" alt="在这里插入图片描述"><br>可以看到的确是return了两次。第一次为{b:10},第二次为{a:{b:10}}；</p><p>另一种实现方法是parse和stringify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;</span><br><span class="line">    name:&#123;age:100&#125;</span><br><span class="line">&#125;</span><br><span class="line">var str &#x3D; JSON.stringify(a)</span><br><span class="line">var b &#x3D; JSON.parse(str)</span><br><span class="line">b.name.age &#x3D; 20</span><br><span class="line">alert(a.name.age) &#x2F;&#x2F;20</span><br></pre></td></tr></table></figure><h2 id="可复用的事件监听方法"><a href="#可复用的事件监听方法" class="headerlink" title="可复用的事件监听方法"></a>可复用的事件监听方法</h2><p>当同一个对象使用.onclick的写法触发多个方法的时候，后一个方法会把前一个方法覆盖掉，也就是说，在对象的onclick事件发生时，只会执行最后绑定的方法。而用事件监听则不会有覆盖的现象，每个绑定的事件都会被执行。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;eventyuan&quot;&gt;点击1&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;eventyuan1&quot;&gt;点击2&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        &#x2F;&#x2F; 当同一个对象使用.onclick的写法触发多个方法的时候， 后一个方法会把前一个方法覆盖掉， 也就是说，</span><br><span class="line">        &#x2F;&#x2F; 在对象的onclick事件发生时， 只会执行最后绑定的方法。 而用事件监听则不会有覆盖的现象， 每个绑定的事件都会被执行。 如下：</span><br><span class="line">        var eventOne &#x3D; function()&#123;</span><br><span class="line">            alert(&#39;第一个监听事件&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        var eventTwo &#x3D; function()&#123;</span><br><span class="line">            alert(&#39;第二个监听事件&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        window.onload &#x3D; function()&#123;</span><br><span class="line">            var btn &#x3D; document.querySelector(&#39;.eventyuan&#39;)</span><br><span class="line">            btn.addEventListener(&#39;click&#39;,eventOne)</span><br><span class="line">            btn.addEventListener(&#39;click&#39;,eventTwo)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 输出第一个监听事件 第二个监听事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 采用事件监听给对象绑定方法后，可以解除相应的绑定，写法如下</span><br><span class="line">        var eventOne &#x3D; function()&#123;</span><br><span class="line">            alert(&#39;第一个监听事件&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        var eventTwo &#x3D; function()&#123;</span><br><span class="line">            alert(&#39;第二个监听事件&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">        window.onload &#x3D; function()&#123;</span><br><span class="line">            var btn1 &#x3D; document.querySelector(&#39;.eventyuan1&#39;)</span><br><span class="line">            btn1.addEventListener(&#39;click&#39;,eventOne)</span><br><span class="line">            btn1.addEventListener(&#39;click&#39;,eventTwo)</span><br><span class="line">            btn1.removeEventListener(&#39;click&#39;,eventOne)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;窗口坐标&quot;&gt;&lt;a href=&quot;#窗口坐标&quot; class=&quot;headerlink&quot; title=&quot;窗口坐标&quot;&gt;&lt;/a&gt;窗口坐标&lt;/h2&gt;</summary>
    
    
    
    <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
    <category term="js基础" scheme="http://yoursite.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数组,重载和多态,作用域,use strict,Typeof,=== 和 == 和 undefined,匿名函数,宿主对象和原生,变量提升,Attribute和property,Document load和document DOMContentLoaded两个事件之前的区别</title>
    <link href="http://yoursite.com/2020/08/22/js%E9%9D%A2%E8%AF%953/"/>
    <id>http://yoursite.com/2020/08/22/js%E9%9D%A2%E8%AF%953/</id>
    <published>2020-08-22T13:58:28.716Z</published>
    <updated>2020-08-26T09:13:20.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><a id="more"></a><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。<br>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。<br>JavaScript 只有声明的变量会提升，初始化的不会</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p><img src="https://img-blog.csdnimg.cn/20200822214720334.png#pic_center" alt="在这里插入图片描述"></p><h2 id="宿主对象和原生对象"><a href="#宿主对象和原生对象" class="headerlink" title="宿主对象和原生对象"></a>宿主对象和原生对象</h2><p>内置（Build-in）对象与原生（Naitve）对象的区别在于：前者总是在引擎初始化阶段，就被创建好的对象，是后者的一个子集；而后者包括了一些在运行过程中动态创建的对象。宿主对象不是引擎的原生对象，而是由宿主框架通过某种机制注册到JavaScript引擎中的对象。<br>因为你不知道哪一天浏览器或javascript本身就会实现这个方法，而且和你扩展的实现有不一致的表现。到时候你的javascript代码可能已经在无数个页面中一直执行，而浏览器的实现导致所有使用扩展原型的代码都崩溃了<br>String对象    字符串对象，提供了对字符串进行操作的属性和方法<br>Array对象    数组对象，提供了数组操作方面的属性和方法<br>Date对象    日期时间对象，可以获取系统的日期时间信息<br>Boolean对象    布尔对象，一个布尔变量就是一个布尔对象。(没有可用的属性和方法)<br>Number对象    数值对象。一个数值变量就是一个数值对象<br>Math对象    数学对象，提供了数学运算方面的属性和方法</p><h2 id="Attribute和property之间的区别"><a href="#Attribute和property之间的区别" class="headerlink" title="Attribute和property之间的区别"></a>Attribute和property之间的区别</h2><p>property是DOM中的属性，是JavaScript里的对象<br>attribute是HTML标签上的特性，它的值只能够是字符串</p><h2 id="Document-load和document-DOMContentLoaded两个事件之前的区别"><a href="#Document-load和document-DOMContentLoaded两个事件之前的区别" class="headerlink" title="Document load和document DOMContentLoaded两个事件之前的区别"></a>Document load和document DOMContentLoaded两个事件之前的区别</h2><p>说明：他们的区别是，触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件<br>DOM文档加载的步骤为<br>1    解析HTML结构<br>2    加载外部脚本和样式表文件<br>3    解析并执行脚本代码<br>4    DOM树构建完成。//DOMContentLoaded<br>5    加载图片等外部文件<br>6    页面加载完毕。//load<br>备注：在第4步，会触发DOMContentLoaded事件。在第6步，触发load事件</p><h2 id="和-和-undefined"><a href="#和-和-undefined" class="headerlink" title="=== 和 == 和 undefined"></a>=== 和 == 和 undefined</h2><p>=== 和 == , [] === [], undefined === undefined,[] == [], undefined == undefined<br>===：三个等号我们称为等同符，当等号两边的值为相同类型的时候，直接比较等号两边的值，值相同则返回true，若等号两边的值类型不同时直接返回false<br>==：两个等号我们称为等值符，当等号两边的值为相同类型时比较值是否相同，类型不同时会发生类型的自动转换，转换为相同的类型后再作比较</p><h2 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h2><p>number    boolean    string    undefined    object    function</p><h2 id="use-strict"><a href="#use-strict" class="headerlink" title="use strict"></a>use strict</h2><p>ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。<br>设立”严格模式”的目的，主要有以下几个：<br>1：消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;<br>2：消除代码运行的一些不安全之处，保证代码运行的安全；<br>3：提高编译器效率，增加运行速度；<br>4：为未来新版本的Javascript做好铺垫。<br>注：经过测试 IE6,7,8,9 均不支持严格模式。<br>缺点：<br>现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性<br>1.全局变量：声明在函数外部的变量（所有没有var直接赋值的变量都属于全局变量）<br>2.局部变量：声明在函数内部的变量（所有没有var直接赋值的变量都属于全局变量）<br>全局变量在整个上下文都有效只是在没有赋值之前调用，会输出undefined<br>函数作用域:是针对局部变量来说的，在函数中定义的变量在函数外不能获取<br>块级作用域:概念“{}”中间的部分都是块级作用域ex：for while if ，js中没有块级作用域，但是可以用闭包实现类似功能</p><h2 id="重载和多态"><a href="#重载和多态" class="headerlink" title="重载和多态"></a>重载和多态</h2><p>多态：    多态的实现可以采用和继承类似的方法。首先定义一个抽象类，其中调用一些虚方法，虚方法在抽象类中没用定义，而是通过其具体的实现类来实现<br>重载：    重载的定义是指函数的方法名相同，但参数不同<br>JS中如何实现方法重载？这涉及到三个问题<br>1    同名函数的调用问题<br>2    函数中特殊的参数arguments<br>3    如何利用arguments实现方法重载<br>实现重载主要就是利用ARGUMENTS</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>常用API<br>操作方法如下<br>concat():    基于当前数组，创建一个新的数组，并返回这个新数组，不会改变原数组<br><br>slice():    可以接受一个或两个参数，要返回项的起始和结束位置，返回所截取数组的项，但是不包括结束位置的项，不会改变原数组<br><br>splice():    主要用法是向数组的中部插入项，会改变原数组，是最强大的数组方法。最多指定3个参数<br><br>indexOf()和lastIndexOf()。这两个方法都接受两个参数：要查找的项和表示查找起点位置的索引。indexOf()从数组的开头开始向后查找，lastIndexOf()从数组的末尾开始向前查找<br><br>迭代方法<br>A    every():对数组的每一项运行给定函数，如果数组的每一项都返回true，则返回true。对数组应用该方法，有返回值为true或false<br><br>B    some():对数组的每一项运行给定函数，如果数组的任一项都返回true，则返回true。对数组应用该方法，有返回值为true或false<br><br>C    filter():对数组的每一项运行给定函数，返回该函数中会返回true的项组成的数组。有返回值，为符合条件的项组成的数组<br><br>D    map()::对数组的每一项运行给定函数,有返回每次函数调用的结果组成的数组<br><br>E    forEach():对数组的每一项运行给定函数,这个方法没有返回值。本质上与使用for循环迭代数组是一样的<br><br>归并方法<br>reduce()和reduceRight()。他们的区别在于从哪头开始遍历数组，除此之外，它们完全相同。 这两个方法都接收两个参宿：一个在每一项上调用的函数和(可选)作为归并基础的初始值。 传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;变量提升&quot;&gt;&lt;a href=&quot;#变量提升&quot; class=&quot;headerlink&quot; title=&quot;变量提升&quot;&gt;&lt;/a&gt;变量提升&lt;/h2&gt;</summary>
    
    
    
    <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
    <category term="js基础" scheme="http://yoursite.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>ajax</title>
    <link href="http://yoursite.com/2020/08/22/ajax/"/>
    <id>http://yoursite.com/2020/08/22/ajax/</id>
    <published>2020-08-22T13:41:00.211Z</published>
    <updated>2020-08-22T13:42:04.061Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="原生创建ajax的五个步骤"><a href="#原生创建ajax的五个步骤" class="headerlink" title="原生创建ajax的五个步骤"></a>原生创建ajax的五个步骤</h2><p>代码引自<a href="https://www.cnblogs.com/0x29a/p/11231950.html">https://www.cnblogs.com/0x29a/p/11231950.html</a></p><h3 id="1-创建XMLHttpRequest异步对象"><a href="#1-创建XMLHttpRequest异步对象" class="headerlink" title="1.创建XMLHttpRequest异步对象"></a>1.创建XMLHttpRequest异步对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest()</span><br></pre></td></tr></table></figure><h3 id="2-设置回调函数"><a href="#2-设置回调函数" class="headerlink" title="2.设置回调函数"></a>2.设置回调函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange &#x3D; callback</span><br></pre></td></tr></table></figure><h3 id="3-使用open方法与服务器简历连接"><a href="#3-使用open方法与服务器简历连接" class="headerlink" title="3.使用open方法与服务器简历连接"></a>3.使用open方法与服务器简历连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;get方式</span><br><span class="line">xhr.open(&#39;get&#39;,&#39;text.php&#39;,true)</span><br><span class="line">&#x2F;&#x2F;post方式，要设置请求头</span><br><span class="line">xhr.open(&#39;post&#39;,&#39;test.php&#39;,true)</span><br><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application&#x2F;x-www-form-urlencoded&quot;)</span><br></pre></td></tr></table></figure><h3 id="4-发送数据"><a href="#4-发送数据" class="headerlink" title="4.发送数据"></a>4.发送数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; get方法不需要传递数据</span><br><span class="line">xhr.send(null)</span><br><span class="line">&#x2F;&#x2F; post 需要传递数据</span><br><span class="line">xhr.send(&#39;name&#x3D;xxx&amp;age&#x3D;18&#39;)</span><br></pre></td></tr></table></figure><h3 id="5-在回调函数中针对不同的响应状态进行处理"><a href="#5-在回调函数中针对不同的响应状态进行处理" class="headerlink" title="5. 在回调函数中针对不同的响应状态进行处理"></a>5. 在回调函数中针对不同的响应状态进行处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function callback()&#123;</span><br><span class="line">      &#x2F;&#x2F; 判断异步对象的状态</span><br><span class="line">    if (xhr.readyState &#x3D;&#x3D; 4) &#123;</span><br><span class="line">          &#x2F;&#x2F; 判断交互是否成功</span><br><span class="line">          if (xhr.status &#x3D;&#x3D; 200) &#123;</span><br><span class="line">              &#x2F;&#x2F; 获取服务器响应的数据</span><br><span class="line">              var res &#x3D; xhr.responseText</span><br><span class="line">                &#x2F;&#x2F; 解析数据</span><br><span class="line">              res &#x3D; JSON.parse(res)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jquery中的ajax"><a href="#jquery中的ajax" class="headerlink" title="jquery中的ajax"></a>jquery中的ajax</h2><p>代码引自 <a href="https://www.cnblogs.com/enumx/p/12326676.html">https://www.cnblogs.com/enumx/p/12326676.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    type:&#39;POST&#39;, &#x2F;&#x2F; 规定请求的类型（GET 或 POST）</span><br><span class="line">    url:uploadV, &#x2F;&#x2F; 请求的url地址</span><br><span class="line">    dataType:&#39;json&#39;, &#x2F;&#x2F;预期的服务器响应的数据类型 </span><br><span class="line">    data:&#123;&#125;,&#x2F;&#x2F;规定要发送到服务器的数据</span><br><span class="line">    beforeSend:function()&#123; &#x2F;&#x2F;发送请求前运行的函数（发送之前就会进入这个函数）</span><br><span class="line">        &#x2F;&#x2F; ....</span><br><span class="line">    &#125;,</span><br><span class="line">    success: function(result)&#123; &#x2F;&#x2F; 当请求成功时运行的函数</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;,</span><br><span class="line">    error:function(result)&#123; &#x2F;&#x2F;失败的函数</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;,</span><br><span class="line">    complete:function()&#123; &#x2F;&#x2F;请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后，不管成功还是失败 都会进这个函数）</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><table><thead><tr><th>async</th><th>布尔值，表示请求是否异步处理。默认是 true。</th></tr></thead><tbody><tr><td>beforeSend(xhr)</td><td>发送请求前运行的函数。</td></tr><tr><td>cache</td><td>布尔值，表示浏览器是否缓存被请求页面。默认是 true</td></tr><tr><td>complete(xhr,status)</td><td>请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）</td></tr><tr><td>contentType</td><td>发送数据到服务器时所使用的内容类型。默认是：”application/x-www-form-urlencoded”。</td></tr><tr><td>context</td><td>为所有 AJAX 相关的回调函数规定 “this” 值。</td></tr><tr><td>password</td><td>规定在 HTTP 访问认证请求中使用的密码。</td></tr><tr><td>jsonpCallback</td><td>在一个 jsonp 中规定回调函数的名称。</td></tr><tr><td>jsonp</td><td>在一个 jsonp 中重写回调函数的字符串。</td></tr><tr><td>ifModified</td><td>布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。</td></tr><tr><td>global</td><td>布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。</td></tr><tr><td>dataType</td><td>预期的服务器响应的数据类型。</td></tr><tr><td>error(xhr,status,error)</td><td>如果请求失败要运行的函数。</td></tr><tr><td>dataFilter(data,type)</td><td>用于处理 XMLHttpRequest 原始响应数据的函数。</td></tr><tr><td>data</td><td>规定要发送到服务器的数据。</td></tr><tr><td>url</td><td>规定发送请求的 URL。默认是当前页面。</td></tr><tr><td>type</td><td>规定请求的类型（GET 或 POST）。</td></tr><tr><td>traditional</td><td>布尔值，规定是否使用参数序列化的传统样式。</td></tr><tr><td>timeout</td><td>设置本地的请求超时时间（以毫秒计）。</td></tr><tr><td>success(result,status,xhr)</td><td>当请求成功时运行的函数。</td></tr><tr><td>scriptCharset</td><td>规定请求的字符集。</td></tr><tr><td>processData</td><td>布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true</td></tr><tr><td>xhr</td><td>用于创建 XMLHttpRequest 对象的函数</td></tr><tr><td>username</td><td>规定在 HTTP 访问认证请求中使用的用户名。</td></tr></tbody></table><h2 id="XMLHttpRequest取得相应"><a href="#XMLHttpRequest取得相应" class="headerlink" title="XMLHttpRequest取得相应"></a>XMLHttpRequest取得相应</h2><ul><li>responseText:获得字符串形式的响应数据</li><li>responseXML：获得xml形式的响应数据</li><li>status和statusText：以数字和文本形势返回http转态码</li><li>getAllResponseHeader():获得所有的相应</li><li>getResponseHeader()：查询相应中的某个字段的值</li><li>readState属性</li></ul><h2 id="readystate的五种返回值所代表的意义："><a href="#readystate的五种返回值所代表的意义：" class="headerlink" title="readystate的五种返回值所代表的意义："></a>readystate的五种返回值所代表的意义：</h2><ul><li>0（未初始化） 还没调用open（）方法</li><li>1（载入）已经调用send方法(),正在发送请求</li><li>2（载入完成）send（）方法已经完成，已收到相应</li><li>3（解析）正在解析响应内容</li><li>4（完成）相应内容解析完成，可在客户端调用。</li></ul><h2 id="ajax中status几种常态说明："><a href="#ajax中status几种常态说明：" class="headerlink" title="ajax中status几种常态说明："></a>ajax中status几种常态说明：</h2><ul><li>100——客户必须继续发出请求</li><li>101——客户要求服务器根据请求转换HTTP协议版本</li><li>200——成功</li><li>201——提示知道新文件的URL</li><li>300——请求的资源可在多处得到</li><li>301——删除请求数据</li><li>404——没有发现文件、查询或URl</li><li>500——服务器产生内部错</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;原生创建ajax的五个步骤&quot;&gt;&lt;a href=&quot;#原生创建ajax的五个步骤&quot; class=&quot;headerlink&quot; title=&quot;原生创建ajax的五个步骤&quot;&gt;&lt;/a&gt;原生创建ajax的五个步骤&lt;/h2&gt;&lt;p&gt;代码引自&lt;a h</summary>
      
    
    
    
    <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
    <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>闭包，this，call,apply,bind区别,原型原型链,创建对象的方式,继承,New 一个对象具体做了什么</title>
    <link href="http://yoursite.com/2020/08/21/js%E9%9D%A2%E8%AF%952/"/>
    <id>http://yoursite.com/2020/08/21/js%E9%9D%A2%E8%AF%952/</id>
    <published>2020-08-21T13:46:53.741Z</published>
    <updated>2020-08-26T09:13:10.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><a id="more"></a><h3 id="对闭包的理解"><a href="#对闭包的理解" class="headerlink" title="对闭包的理解"></a>对闭包的理解</h3><p>函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。闭包就是能够读取其他函数内部变量的函数。内部函数对外部函数的变量有了引用关系——闭包就是这时产生的。每次对外部函数的调用，都会产生一次闭包。</p><h4 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h4><p>1 给函数添加一些属性<br>2 声明一个变量，将一个函数当做值赋给变量<br>3 new一个对象，然后给对象添加属性和方法<br>4 var obj={}就是声明一个空的对象</p><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p>它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。<br>（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h4 id="this的使用场景"><a href="#this的使用场景" class="headerlink" title="this的使用场景"></a>this的使用场景</h4><p>1    全局&amp;调用普通函数，在全局环境中，this永远指向window<br>2    构造函数，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象<br>3    对象方法，如果函数作为对象的方法时，方法中的 this 指向该对象。注意：若是在对象方法中定义函数，那么情况就不同了。函数a    虽然是在b内部定义的,但它仍然属于一个普通函数，this仍指向window<br>4    构造函数 prototype 属性，即便是在整个原型链中，this 代表的也是当前对象的值<br>5    函数用 call、apply或者 bind 调用，当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值<br>6    DOM event this，前六种情况其实可以总结为： this 指向调用该方法的对象<br>7    箭头函数中的 this，当使用箭头函数的时候，情况就有所不同了：箭头函数内部的 this 是词法作用域，由上下文确定<br>java中this.value可以再本类中调用全局变量,也可以在构造器中用this()调用其他构造器,也可以用this表示当前对象JavaScript中this指的是这个函数所属的对象的值,当new一个函数时,这个this就会指向这个new出来的对象,apply()和call()可以改变一个函数中this指向的对象call和apply都可以改变this指向，不过call的第二个参数是散列分布，apply则可以是一个数组</p><h2 id="call-apply-bind区别"><a href="#call-apply-bind区别" class="headerlink" title="call,apply,bind区别"></a>call,apply,bind区别</h2><p>call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。<br>call()在第一个参数之后的  后续所有参数就是传入该函数的值。<br>apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。<br>bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是直接执行该函数。他的参数和call()相同。</p><h2 id="原型原型链"><a href="#原型原型链" class="headerlink" title="原型原型链"></a>原型原型链</h2><p>在JS中万物皆对象，方法(FUNCTION)是对象，方法的原型（FUNCTION.PROTOTYPE）是对象，对象具有属性（__PROTO__）称为隐式原型，对象的隐式原型指向构造该对象的构造函数的显式原型。原型对象只存在于函数对象。也就是本质上只要是通过NEW FUNCTION创建的函数对象会有一个原型对象</p><h4 id="五条原型原则"><a href="#五条原型原则" class="headerlink" title="五条原型原则"></a>五条原型原则</h4><p>1    所有的引用类型（数组，对象，函数）都具有对象特性，即可自由扩展属性（除了null以外）<br>2    所有的引用类型（数组，对象，函数），都有一个<em>proto_属性，属性值是一个普通的对象    （隐式原型）<br>3    当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto</em>(即它的构造函数的prototype)中寻找</p><h4 id="原型链解释说明"><a href="#原型链解释说明" class="headerlink" title="原型链解释说明"></a>原型链解释说明</h4><ol><li>INSTANCEOF用于判断引用类型属于那个构造函数的方法，F INSTANCEOF FOO的判断逻辑是：F的_PROTO_一层一层往上，能否对应到FOO.PROTOTYPE再试着判断 F   INSTANCEOF   OBJECT。</li><li>INSTANCEOF用于判断引用类型属于那个构造函数的方法F INSTANCEOF FOO的判断逻辑是：F的_PROTO_一层一层往上，能否对应到FOO.PROTOTYPE再试着判断 F   INSTANCEOF   OBJECT。<h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2>工厂模式<br>构造函数模式<br>原型模式<br>组合使用构造模式和原型模式<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><table><thead><tr><th>原型继承</th><th>优点：父类的方法（getName）得到了复用  缺点：同理父类的属性（name）也是复用，即子类实例没有自己的属性</th></tr></thead><tbody><tr><td>构造函数继承</td><td>优点：子类的每个实例都有自己的属性（name），不会相互影响缺点：但是继承父类方法的时候就不需要这种特性，没有实现父类方法的复用</td></tr><tr><td>组合式继承</td><td>优点：继承了上述两种方式的优点，摒弃了缺点，复用了方法，子类又有各自的属性缺点： 因为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例(sub1,sub2)的属性覆盖掉，也存在内存浪费</td></tr><tr><td>寄生组合式继承</td><td>优点：以上优点均有。 缺点：就是在继承父类方法的时候调用了父类构造函数，从而造成内存浪费，// 现在只要解决了这个问题就完美了。那在复用父类方法的时候，// 使用Object.create方法也可以达到目的，没有调用父类构造函数，问题解决</td></tr></tbody></table></li></ol><h2 id="New-一个对象具体做了什么"><a href="#New-一个对象具体做了什么" class="headerlink" title="New 一个对象具体做了什么"></a>New 一个对象具体做了什么</h2><p>使用关键字new创建新实例对象过了以下几步<br>1    创建一个新对象，如：var person = {}<br>2    新对象的_proto_属性指向构造函数的原型对象<br>3    将构造函数的作用域赋值给新对象。（也所以this对象指向新对象）<br>4    执行构造函数内部的代码，将属性添加给person中的this对象<br>5    返回新对象person</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;</summary>
    
    
    
    <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
    <category term="js基础" scheme="http://yoursite.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>js的基本类型，引用类型有哪些，null和undefined的区别，判断一个变量是Array类型,判断一个变量是Number类型，Object是什么类型，引用类型和基本数据类型有什么区别，堆栈关系， JS常见的DOM操作API，JS常见的DOM操作API，事件委托,事件冒泡和捕获，如何阻止冒泡,如何阻止默认事件</title>
    <link href="http://yoursite.com/2020/08/21/js%E9%9D%A2%E8%AF%951/"/>
    <id>http://yoursite.com/2020/08/21/js%E9%9D%A2%E8%AF%951/</id>
    <published>2020-08-21T10:39:35.073Z</published>
    <updated>2020-08-26T09:12:56.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js的基本类型，引用类型有哪些，null和undefined的区别"><a href="#js的基本类型，引用类型有哪些，null和undefined的区别" class="headerlink" title="js的基本类型，引用类型有哪些，null和undefined的区别"></a>js的基本类型，引用类型有哪些，null和undefined的区别</h2><a id="more"></a><p><strong>基本数据类型</strong>：undefined,null,boolean,number,string<br><strong>引用数据类型</strong>：function,obiect,array<br><strong>Undefined</strong>:表示变量声明但未初始化时的值<br><strong>null</strong>表示准备用来保存对象，还没有真正保存对象的值。从逻辑角度看，null值表示一个空对象指针。<br>JavaScript（ECMAScript标准）里共有5种基本类型：Undefined, Null, Boolean, Number, String，和一种复杂类型Object。可以看到null和undefined分属不同的类型，未初始化定义的值用typeof检测出来是”undefined”(字符串)，而null值用typeof检测出来是”object”（字符串）。任何时候都不建议显式的设置一个变量为undefined，但是如果保存对象的变量还没有真正保存对象，应该设置成null。实际上，undefined值是派生自null值的，ECMAScript标准规定对二者进行相等性测试要返回true</p><h2 id="判断一个变量是Array类型-判断一个变量是Number类型"><a href="#判断一个变量是Array类型-判断一个变量是Number类型" class="headerlink" title="判断一个变量是Array类型,判断一个变量是Number类型"></a>判断一个变量是Array类型,判断一个变量是Number类型</h2><p>从原型入手，Array.prototype.isPrototypeOf(obj);也可以从构造函数入手，obj instanceof Array根据对象的class属性(类属性)，跨原型链调用toString()方法。Array.isArray()方法。<br>isNaN（）是一个函数，用isNaN判断一个变量，返回一个Boolean值。若返回的值为false，则为可以转换成数字类型；返回的值是true，则不能转换成数字类型<br>Typeof () 判断</p><h2 id="Object是什么类型，引用类型和基本数据类型有什么区别，堆栈关系"><a href="#Object是什么类型，引用类型和基本数据类型有什么区别，堆栈关系" class="headerlink" title="Object是什么类型，引用类型和基本数据类型有什么区别，堆栈关系"></a>Object是什么类型，引用类型和基本数据类型有什么区别，堆栈关系</h2><p>Object 是引用类型。<br><strong>基本类型：</strong>1.基本类型的值是不可变得，2.基本类型的比较是值的比较。3.基本类型的变量是存放在栈区的（栈区指内存里的栈内存）。<br><strong>引用类型：</strong>1.引用类型的值是可变的，2.引用类型的值是同时保存在栈内存和堆内存中的对象。<br><strong>引用类型与基本类型比较</strong><br>基本类型：string,number,boolean,null,undefined<br>引用类型：Function,Array,Object<br>访问方式<br>基本类型：操作和保存在变量的实际的值<br>引用类型：存在内存中，js不许直接访问内存，操作的是对象的引用<br>存储的位置<br>基本类型：保存在栈区<br>引用类型：引用存放在栈区，实际对象保存在堆区。</p><center>保存在栈区</center><p><img src="https://img-blog.csdnimg.cn/20200821173535939.png#pic_center" alt="在这里插入图片描述"></p><center>引用存放在栈区，实际对象保存在堆区。</center><p><img src="https://img-blog.csdnimg.cn/20200821173545237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="JS常见的DOM操作API"><a href="#JS常见的DOM操作API" class="headerlink" title="JS常见的DOM操作API"></a>JS常见的DOM操作API</h2><p>   <img src="https://img-blog.csdnimg.cn/20200821173734509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200821173743285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY5MzcxMg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="事件冒泡和事件捕获"><a href="#事件冒泡和事件捕获" class="headerlink" title="事件冒泡和事件捕获"></a>事件冒泡和事件捕获</h2><p>当你使用事件捕获时，父级元素先触发，子级元素后触发。<br>当你使用事件冒泡时，子级元素先触发，父级元素后触发。</p><h2 id="事件委托-事件冒泡和捕获，如何阻止冒泡-如何阻止默认事件"><a href="#事件委托-事件冒泡和捕获，如何阻止冒泡-如何阻止默认事件" class="headerlink" title="事件委托,事件冒泡和捕获，如何阻止冒泡,如何阻止默认事件"></a>事件委托,事件冒泡和捕获，如何阻止冒泡,如何阻止默认事件</h2><h3 id="事件委托：（参考：https-www-cnblogs-com-liugang-vip-p-5616484-html）"><a href="#事件委托：（参考：https-www-cnblogs-com-liugang-vip-p-5616484-html）" class="headerlink" title="事件委托：（参考：https://www.cnblogs.com/liugang-vip/p/5616484.html）"></a>事件委托：（参考：<a href="https://www.cnblogs.com/liugang-vip/p/5616484.html%EF%BC%89">https://www.cnblogs.com/liugang-vip/p/5616484.html）</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;事件委托&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .active&#123;</span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button class&#x3D;&quot;toolbar&quot;&gt;事件委托&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var  toobal &#x3D; document.querySelector(&#39;.toolbar&#39;)</span><br><span class="line">        toobal.addEventListener(&quot;click&quot;,function(e)&#123;</span><br><span class="line">            var button &#x3D; e.target</span><br><span class="line">            if(!button.classList.contains(&#39;active&#39;))&#123;</span><br><span class="line">                button.classList.add(&#39;active&#39;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                button.classList.remove(&#39;active&#39;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="事件冒泡："><a href="#事件冒泡：" class="headerlink" title="事件冒泡："></a>事件冒泡：</h3><p>事件冒泡，就是元素自身的事件被触发后，如果父元素有相同的事件，如onclick事件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，直到document/window，冒泡过程结束。<br>但是事件冒泡在某些应用场景产生一些问题，就是我们不需要触发的事件，由于冒泡的原因，也会运行。所以在这个时候要取消事件冒泡。阻止事件冒泡如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;段落文本内容</span><br><span class="line">            &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;点击&quot; id&#x3D;&quot;button&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">    </span><br><span class="line">var button &#x3D; document.querySelector(&#39;#button&#39;)</span><br><span class="line">    button.click&#x3D;function(event)&#123;</span><br><span class="line">        &#x2F;&#x2F;阻止冒泡</span><br><span class="line">        event &#x3D; event || window.event</span><br><span class="line">        if (event &amp;&amp; event.stopPropagation) &#123;</span><br><span class="line">            event.stopPropagation()</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            event.CancelBubble &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>（参考：<a href="https://www.cnblogs.com/zhuzhenwei918/p/6139880.html%EF%BC%89">https://www.cnblogs.com/zhuzhenwei918/p/6139880.html）</a><br>事件捕获，与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p。阻止事件冒泡如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;second&quot;).addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert(&quot;second&quot;);</span><br><span class="line">    event.stopImmediatePropagation();</span><br><span class="line">&#125;,true); </span><br></pre></td></tr></table></figure><h3 id="阻止浏览器默认行为"><a href="#阻止浏览器默认行为" class="headerlink" title="阻止浏览器默认行为"></a>阻止浏览器默认行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 阻止浏览器默认行为</span><br><span class="line"> function stopDefault(e)&#123;</span><br><span class="line">     if(e &amp;&amp; e.preventDefault)&#123;</span><br><span class="line">         &#x2F;&#x2F; 阻止浏览器默认行为W3C</span><br><span class="line">         e.preventDefault();</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         &#x2F;&#x2F; IE中阻止浏览器默认行为</span><br><span class="line">         window.event.returnValue &#x3D; false</span><br><span class="line">     &#125;</span><br><span class="line">     return false;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;js的基本类型，引用类型有哪些，null和undefined的区别&quot;&gt;&lt;a href=&quot;#js的基本类型，引用类型有哪些，null和undefined的区别&quot; class=&quot;headerlink&quot; title=&quot;js的基本类型，引用类型有哪些，null和undefined的区别&quot;&gt;&lt;/a&gt;js的基本类型，引用类型有哪些，null和undefined的区别&lt;/h2&gt;</summary>
    
    
    
    <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
    <category term="js基础" scheme="http://yoursite.com/tags/js%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>两栏布局,DPI,Attribute / property,流式布局和响应式布局，BFC,雪碧图 （ 精灵图 ），SVG，浏览器兼容问题，“::before”和“:after”中的双冒号和单冒号的区别</title>
    <link href="http://yoursite.com/2020/08/19/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80,DPI,Attribute%20%EF%BC%8Cproperty,%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%EF%BC%8CBFC,%E9%9B%AA%E7%A2%A7%E5%9B%BE%20%EF%BC%88%20%E7%B2%BE%E7%81%B5%E5%9B%BE%20%EF%BC%89%EF%BC%8CSVG%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98before%E5%92%8Cafter%E4%B8%AD%E7%9A%84%E5%8F%8C%E5%86%92%E5%8F%B7%E5%92%8C%E5%8D%95%E5%86%92%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/08/19/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80,DPI,Attribute%20%EF%BC%8Cproperty,%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%EF%BC%8CBFC,%E9%9B%AA%E7%A2%A7%E5%9B%BE%20%EF%BC%88%20%E7%B2%BE%E7%81%B5%E5%9B%BE%20%EF%BC%89%EF%BC%8CSVG%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98before%E5%92%8Cafter%E4%B8%AD%E7%9A%84%E5%8F%8C%E5%86%92%E5%8F%B7%E5%92%8C%E5%8D%95%E5%86%92%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-08-19T09:31:47.712Z</published>
    <updated>2020-08-19T09:27:10.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两栏布局-DPI-Attribute-property-流式布局和响应式布局，BFC-雪碧图-（-精灵图-），SVG，浏览器兼容问题，“-before”和“-after”中的双冒号和单冒号的区别"><a href="#两栏布局-DPI-Attribute-property-流式布局和响应式布局，BFC-雪碧图-（-精灵图-），SVG，浏览器兼容问题，“-before”和“-after”中的双冒号和单冒号的区别" class="headerlink" title="两栏布局,DPI,Attribute / property,流式布局和响应式布局，BFC,雪碧图 （ 精灵图 ），SVG，浏览器兼容问题，“::before”和“:after”中的双冒号和单冒号的区别"></a>两栏布局,DPI,Attribute / property,流式布局和响应式布局，BFC,雪碧图 （ 精灵图 ），SVG，浏览器兼容问题，“::before”和“:after”中的双冒号和单冒号的区别</h2><a id="more"></a><h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><p>1    margin-bottom和padding-bottom<br>2    table-row和table-cell<br>3    flex布局</p><h2 id="DPI（移动端）"><a href="#DPI（移动端）" class="headerlink" title="DPI（移动端）"></a>DPI（移动端）</h2><p>Dpi:每英寸包含点的数量(dots per inch)<br>普通屏幕通常包含96dpi,一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi(即2dppx),打印时一般会需要更大的dpi;<br>1dppx=96dpi    1dpi约等于0.39dpcm    1dpcm约等于2.54dpi<br>1in =2.54cm=25.4mm=101.6q=72pt=6pc=96px;<br>支持IE9+  firefox3.5+  chrome29.0+</p><h2 id="Attribute-property"><a href="#Attribute-property" class="headerlink" title="Attribute / property"></a>Attribute / property</h2><p>Property    它是DOM中的属性，是javascript里边的对象<br>Attribute    它是HTML标签上的特性，它的值只能够是字符串</p><h2 id="流式布局和响应式布局"><a href="#流式布局和响应式布局" class="headerlink" title="流式布局和响应式布局"></a>流式布局和响应式布局</h2><table><thead><tr><th>流式布局</th><th>响应式布局</th></tr></thead><tbody><tr><td>也叫fluid,当上面一行的空间不够容纳新的TextView时候才开辟下一行的空间，场景：主要用于关键词搜索或者热门标签等场景；他主要是按照页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变,使用%百分比定义宽度，高度大都是用px来固定，可以根据可视区域和父元素的实时尺寸来调整，尽可能适应各种分辨率</td><td>主要是实现不同屏幕分辨率的终端上浏览网页的不同展示方式，通过响应式设计能使网站在手机和平板电脑上有更好的浏览阅读体验；首先设置meta标签，通过媒体查询来设置样式Media Queries,然后再设置多种试图宽度</td></tr></tbody></table><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC：简单说，它是一种属性，这种属性会影响着元素的定位以及与其兄弟元素之间的相互作用<br>如何创建BFC：当一个HTML元素满足下面条件的任何一点，都可以产生BFC,常见的，float的值不为‘none’，overflow的值不为‘visible’,display的值为‘table-cell’,‘table-caption’,or‘inline-block’中的任何一个，position的值不为‘static’或‘relative’中的任何一个创建一个BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC仍然属于文档中的普通流</p><h2 id="雪碧图-（-精灵图-）"><a href="#雪碧图-（-精灵图-）" class="headerlink" title="雪碧图 （ 精灵图 ）"></a>雪碧图 （ 精灵图 ）</h2><p>是把网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量，该图片使用css background和background-position属性渲染，这也就意味着你的标签变得更复杂了，图片是在css中定义，并非在<img>标签中，优点：减少加载网页图片时对服务器的请求次数，可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量。</p><h2 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h2><p>SVG它是可伸缩矢量图形，用来定义用于网络的基于矢量的图形，图形在放大或者改变尺寸的情况，其图形质量不会有所损失。<br>33.    工作中遇到的浏览器兼容问题有哪些？你都知道哪些常用的HACK技巧？</p><h2 id="浏览器兼容问题"><a href="#浏览器兼容问题" class="headerlink" title="浏览器兼容问题"></a>浏览器兼容问题</h2><p>1：不同浏览器的默认初始值不同。<br>解决方法：引入全局控制样式，或者使用第三方<br>2：块属性标签float后，又有横行的margin的情况下，在IE6显示margin比设置的大。<br>解决方法：在float的标签样式控制中加入display:inline,将其转化为行内属性。<br>3：设置小于10px高度标签，在IE6,7,无法正常显示设置高度。<br>解决方法：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度<br>4：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug<br>解决方法：在display:block;后面加入display:inline;display:table;<br>5：图片默认有间距。<br>解决方法：使用float属性为img布局。<br>6：标签最低高度设置min-height不兼容。<br>解决方法：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}<br><strong>常用的HACK技巧</strong><br>Ie浏览器hack如下<br>_nowamagic:1px;———–ie6 *nowamagic:1px;———–ie7 nowamagic:1px\0;———-ie89 nowamagic:1px\9\0;——–ie9  :root nowamagic:1px;    —-ie9<br>Firefox 与 Chrome 的 Hack<br>Firefox:@-moz-document url-prefix()  /<em>写在选择器外层时（只可写在此处）：Firefox only</em>/<br>Chrome:@media screen and (-webkit-min-device-pixel-ratio:0)  /<em>写在选择器外层时（只可写在此处）：Chrome only</em>/</p><h2 id="“-before”和“-after”中的双冒号和单冒号的区别"><a href="#“-before”和“-after”中的双冒号和单冒号的区别" class="headerlink" title="“::before”和“:after”中的双冒号和单冒号的区别"></a>“::before”和“:after”中的双冒号和单冒号的区别</h2><p>如果你的网站只需要兼容webkit、firefox、opera等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容IE浏览器，还是用CSS2的单冒号写法比较安全</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;两栏布局-DPI-Attribute-property-流式布局和响应式布局，BFC-雪碧图-（-精灵图-），SVG，浏览器兼容问题，“-before”和“-after”中的双冒号和单冒号的区别&quot;&gt;&lt;a href=&quot;#两栏布局-DPI-Attribute-property-流式布局和响应式布局，BFC-雪碧图-（-精灵图-），SVG，浏览器兼容问题，“-before”和“-after”中的双冒号和单冒号的区别&quot; class=&quot;headerlink&quot; title=&quot;两栏布局,DPI,Attribute / property,流式布局和响应式布局，BFC,雪碧图 （ 精灵图 ），SVG，浏览器兼容问题，“::before”和“:after”中的双冒号和单冒号的区别&quot;&gt;&lt;/a&gt;两栏布局,DPI,Attribute / property,流式布局和响应式布局，BFC,雪碧图 （ 精灵图 ），SVG，浏览器兼容问题，“::before”和“:after”中的双冒号和单冒号的区别&lt;/h2&gt;</summary>
    
    
    
    <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
    <category term="css基础" scheme="http://yoursite.com/tags/css%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>盒模型，box-sizing，CSS3新特性，伪类，伪元素，锚伪类，使用CSS实现隐藏元素的方式,盒子在页面水平和垂直居中, inline和inline-block,块级元素,行级元素有哪些以及特点 ,网格布局,传统表格布局</title>
    <link href="http://yoursite.com/2020/08/19/%E7%9B%92%E6%A8%A1%E5%9E%8B%EF%BC%8Cbox-sizing%EF%BC%8CCSS3%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%8C%E4%BC%AA%E7%B1%BB%EF%BC%8C%E4%BC%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E9%94%9A%E4%BC%AA%E7%B1%BB%EF%BC%8C%E4%BD%BF%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E5%BC%8F,%E7%9B%92%E5%AD%90%E5%9C%A8%E9%A1%B5%E9%9D%A2%E6%B0%B4%E5%B9%B3%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD,%20inline%E5%92%8Cinline-block,%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0,%E8%A1%8C%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BB%A5%E5%8F%8A%E7%89%B9%E7%82%B9%20,%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80,%E4%BC%A0%E7%BB%9F%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2020/08/19/%E7%9B%92%E6%A8%A1%E5%9E%8B%EF%BC%8Cbox-sizing%EF%BC%8CCSS3%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%8C%E4%BC%AA%E7%B1%BB%EF%BC%8C%E4%BC%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E9%94%9A%E4%BC%AA%E7%B1%BB%EF%BC%8C%E4%BD%BF%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E5%BC%8F,%E7%9B%92%E5%AD%90%E5%9C%A8%E9%A1%B5%E9%9D%A2%E6%B0%B4%E5%B9%B3%E5%92%8C%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD,%20inline%E5%92%8Cinline-block,%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0,%E8%A1%8C%E7%BA%A7%E5%85%83%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BB%A5%E5%8F%8A%E7%89%B9%E7%82%B9%20,%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80,%E4%BC%A0%E7%BB%9F%E8%A1%A8%E6%A0%BC%E5%B8%83%E5%B1%80/</id>
    <published>2020-08-19T09:31:47.684Z</published>
    <updated>2020-08-19T09:08:11.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="盒模型，box-sizing，CSS3新特性，伪类，伪元素，锚伪类，使用CSS实现隐藏元素的方式-盒子在页面水平和垂直居中-inline和inline-block-块级元素-行级元素有哪些以及特点-网格布局-传统表格布局"><a href="#盒模型，box-sizing，CSS3新特性，伪类，伪元素，锚伪类，使用CSS实现隐藏元素的方式-盒子在页面水平和垂直居中-inline和inline-block-块级元素-行级元素有哪些以及特点-网格布局-传统表格布局" class="headerlink" title="盒模型，box-sizing，CSS3新特性，伪类，伪元素，锚伪类，使用CSS实现隐藏元素的方式,盒子在页面水平和垂直居中, inline和inline-block,块级元素,行级元素有哪些以及特点 ,网格布局,传统表格布局"></a>盒模型，box-sizing，CSS3新特性，伪类，伪元素，锚伪类，使用CSS实现隐藏元素的方式,盒子在页面水平和垂直居中, inline和inline-block,块级元素,行级元素有哪些以及特点 ,网格布局,传统表格布局</h2><a id="more"></a><h3 id="盒模型："><a href="#盒模型：" class="headerlink" title="盒模型："></a>盒模型：</h3><p>margin(外边距)   padding(内边距)   border(边框)  content(内容)</p><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing:"></a>box-sizing:</h2><p>content-box  / border-box  /  inherit有以下三个属性<br><br>1：content-box:指定元素的宽度和高度（最小/最大属性）适用于box的宽度和高度，元素的填充和边框布局和绘制指定宽度和高度除外.<br><br>2 ：border-box:指定宽度和高度（最小/最大属性）确定元素边框box，对元素指定宽度和高度包括padding和border的指定，内容的宽度和高度减去各自双方该边框和填充的宽度从指定的“宽度”和“高度”属性计算<br><br>3 ：inherit:指定box-sizing属性的值，应该从父元素继承</p><h2 id="C3新特性："><a href="#C3新特性：" class="headerlink" title="C3新特性："></a>C3新特性：</h2><p>1    CSS实现圆角（border-radius）,阴影（box-shadow）,边框图片border-image<br><br>2    对文字加特效（text-shadow）,强制文本换行（word-wrap）,线性渐变（linear-gradient）<br><br>3    旋转，缩放，定位，倾斜： transform:rotate(90deg)  scale(0.85,0.90)  translate(0px,-30px)  skew(-9deg,0deg)<br><br>4    增加了更多的CSS选择器，多背景，rgba();<br><br>5    在CSS3中唯一引入的伪元素是::selection;<br><br>6    媒体查询（@media）,多栏布局（flex）<br></p><h2 id="伪类：用于向某些选择器添加特殊的效果"><a href="#伪类：用于向某些选择器添加特殊的效果" class="headerlink" title="伪类：用于向某些选择器添加特殊的效果"></a>伪类：用于向某些选择器添加特殊的效果</h2><p>1    ：hover 将样式添加到鼠标悬浮的元素<br><br>2    ：active 将样式添加到被激活的元素<br><br>3    ：focus 将样式添加到获得焦点的元素<br><br>4    ：link 将样式添加到未被访问过的链接<br><br>5    ：visited 将样式添加到被访问过的链接<br><br>6    ：first-child 将样式添加到元素的第一个子元素<br><br>7    ：lang 定义指定的元素中使用的语言<br></p><h2 id="伪元素：用于将特殊的效果添加到某些选择器，伪元素代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中"><a href="#伪元素：用于将特殊的效果添加到某些选择器，伪元素代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中" class="headerlink" title="伪元素：用于将特殊的效果添加到某些选择器，伪元素代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中"></a>伪元素：用于将特殊的效果添加到某些选择器，伪元素代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中</h2><p>1    ::first-letter 将样式添加到文本的首字母<br><br>2    ::first-line 将样式添加到文本的首行<br><br>3    ::before 在某元素之前插入某些内容<br><br>4    ::after 在某元素之后插入某些内容<br></p><h2 id="新增伪类："><a href="#新增伪类：" class="headerlink" title="新增伪类："></a>新增伪类：</h2><table><thead><tr><th>P:first-of-type</th><th>选择属于其父元素的首个p元素的每个p元素</th></tr></thead><tbody><tr><td>P:last-of-type</td><td>选择属于其父元素的最后p元素的每个p元素</td></tr><tr><td>P:only-of-type</td><td>选择属于其父元素唯一的p元素的每个p元素</td></tr><tr><td>P:only-child</td><td>选择属于其父元素唯一的子元素的每个p元素</td></tr><tr><td>P:nth-child(n)</td><td>选择属于其父元素的第n个子元素的每个p元素</td></tr><tr><td>P:nth-last-child(n)</td><td>选择属于其父元素的倒数第n个子元素的每个p元素</td></tr><tr><td>P:nth-of-type(n)</td><td>选择属于其父元素第n个p元素的每个p元素</td></tr><tr><td>P:nth-last-of-type(n)</td><td>选择属于其父元素倒数第n个p元素的每个p元素</td></tr><tr><td>P:last-child</td><td>选择属于其父元素最后一个子元素的每个p元素</td></tr><tr><td>P:empty</td><td>选择没有子元素的每个p元素(包括文本节点)</td></tr><tr><td>P:target</td><td>选择当前活动的p元素</td></tr><tr><td>:not(p)</td><td>选择非p元素的每个元素</td></tr><tr><td>:enabled</td><td>控制表单控件的可用状态</td></tr><tr><td>:disabled</td><td>控制表单控件的禁用状态</td></tr></tbody></table><h2 id="使用CSS实现隐藏元素的方式"><a href="#使用CSS实现隐藏元素的方式" class="headerlink" title="使用CSS实现隐藏元素的方式"></a>使用CSS实现隐藏元素的方式</h2><p>1    Opacity:设置一个元素的透明度   .hide{opacity:0;}<br><br>2    Visibility  .hide{visibility:hidden}<br><br>3    Display:确保元素不可见并且连盒模型也不生成 .hide{display:none}<br><br>4    Position .hide{position:absolute; top:-9999px; left:-9999px;}<br><br>5    Clip-path  .hide{clip-path:polygon(0px 0px, 0px 0px, 0px 0px, 0px 0px};<br></p><h2 id="盒子在页面水平和垂直居中"><a href="#盒子在页面水平和垂直居中" class="headerlink" title="盒子在页面水平和垂直居中"></a>盒子在页面水平和垂直居中</h2><p>水平居中设置：<br>1    行内元素：设置text-align:center;<br>2    定宽块状元素：设置 左右 margin值为auto;<br>3    不定宽块状元素<br>4    在元素外加入 table标签(完整的，包括table,tbody,tr,td),该元素写在td内，然后设置margin的值为auto;<br>5    给该元素设置display:inline方法；<br>6    父元素设置position:relative和left:50%,子元素设置position:relative和left:50%<br><br>垂直居中设置:<br>1    父元素高度确定的单行文本，设置height=line-height;<br>2    父元素高度确定的多行文本<br>A:插入table（插入方法和水平居中一样）,然后设置vertical-align:middle;<br> B:先设置display:table-cell 再设置 vertical-align:middle;</p><h2 id="position-display"><a href="#position-display" class="headerlink" title="position,display"></a>position,display</h2><p><strong>position</strong><br>position：absolute;    绝对定位的元素，相对于static定位以外的第一个父元素进行定位<br>position:fixed;    生成绝对定位的元素，相对于浏览器窗口进行定位.<br>position:relative;    生成相对定位的元素，相对于其正常位置进行定位<br>position:static;    默认值，没有定位，元素在正常的文档流(忽略top,bottom,left,right或者z-index声明)<br>position:inherit;    规定应该从父元素继承position属性的值<br><strong>display: ( 经常使用的 )</strong><br>display:none    此元素不会被显示<br>display:block;    此元素将显示为块级元素，此元素前后会带有换行符<br>display:inline;    行内块元素<br>display:inline-block;    此元素会作为列表显示<br>提示：基础知识，必须要了解！</p><h2 id="inline和inline-block"><a href="#inline和inline-block" class="headerlink" title="inline和inline-block"></a>inline和inline-block</h2><p><strong>inline</strong><br>1    inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化<br>2    Inline元素设置width,height属性无效<br>3    inline元素的margin和padding属性，水平方向的padding-left,padding-right,margin-left,margin-right都产生边距效果；但竖直方向的padding-top,padding-bottom,magin-top,margin-bottom不会产生边距效果。</p><h2 id="块级元素-行级元素有哪些以及特点"><a href="#块级元素-行级元素有哪些以及特点" class="headerlink" title="块级元素,行级元素有哪些以及特点"></a>块级元素,行级元素有哪些以及特点</h2><table><thead><tr><th>行内元素</th><th>块级元素</th></tr></thead><tbody><tr><td>a b em font i  img input br label span small select textarea</td><td>address dl div form h1-h6 hr menu ol p</td></tr><tr><td>行内元素不会独占一行，相邻的行内元素会排列在同一行里，一行排不下会自动换行，其宽度随元素的内容而变化。</td><td>块级元素会独占一行，其宽度自动填满其父元素宽度</td></tr><tr><td>块级元素可以设置margin,padding,行内元素的水平方向的padding-left，padding-right，margin-left，margin-right都产生边距效果，但是竖直方向padding-top,padding-bottom,margin-top,margin-bottom都不会产生边距效果</td><td>块级元素可以设置width,height属性，行内元素设置宽高无效</td></tr></tbody></table><h2 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h2><p>Grid布局又称“网格”，是一个基于二维网格布局的系统，主要目的是改变我们基于网格设计的用户接口方式，Grid布局是第一个专门为解决布局问题而创建的CSS模块</p><h2 id="传统表格布局"><a href="#传统表格布局" class="headerlink" title="传统表格布局"></a>传统表格布局</h2><p>Table用于布局，主要用来显示批量的数据；但是table有一个缺点，就是加载页面的时候，需要将全部的数据都请求到，才显示页面，否则就是一片的空白，所以现在一般都不用table进行布局.但因其稳定性非常优秀，一般在管理系统类项目中应用较多。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;盒模型，box-sizing，CSS3新特性，伪类，伪元素，锚伪类，使用CSS实现隐藏元素的方式-盒子在页面水平和垂直居中-inline和inline-block-块级元素-行级元素有哪些以及特点-网格布局-传统表格布局&quot;&gt;&lt;a href=&quot;#盒模型，box-sizing，CSS3新特性，伪类，伪元素，锚伪类，使用CSS实现隐藏元素的方式-盒子在页面水平和垂直居中-inline和inline-block-块级元素-行级元素有哪些以及特点-网格布局-传统表格布局&quot; class=&quot;headerlink&quot; title=&quot;盒模型，box-sizing，CSS3新特性，伪类，伪元素，锚伪类，使用CSS实现隐藏元素的方式,盒子在页面水平和垂直居中, inline和inline-block,块级元素,行级元素有哪些以及特点 ,网格布局,传统表格布局&quot;&gt;&lt;/a&gt;盒模型，box-sizing，CSS3新特性，伪类，伪元素，锚伪类，使用CSS实现隐藏元素的方式,盒子在页面水平和垂直居中, inline和inline-block,块级元素,行级元素有哪些以及特点 ,网格布局,传统表格布局&lt;/h2&gt;</summary>
    
    
    
    <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
    <category term="css基础" scheme="http://yoursite.com/tags/css%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>什么是渐进式渲染</title>
    <link href="http://yoursite.com/2020/08/17/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2020/08/17/%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%B8%B2%E6%9F%93/</id>
    <published>2020-08-17T14:45:29.287Z</published>
    <updated>2020-08-19T09:09:27.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是渐进式渲染"><a href="#什么是渐进式渲染" class="headerlink" title="什么是渐进式渲染"></a>什么是渐进式渲染</h2><a id="more"></a><p>指打开页面先加载首屏显示的内容，之后再随着时间或者滚动页面才进行后面的加载</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是渐进式渲染&quot;&gt;&lt;a href=&quot;#什么是渐进式渲染&quot; class=&quot;headerlink&quot; title=&quot;什么是渐进式渲染&quot;&gt;&lt;/a&gt;什么是渐进式渲染&lt;/h2&gt;</summary>
    
    
    
    <category term="Html" scheme="http://yoursite.com/categories/Html/"/>
    
    
    <category term="html基础" scheme="http://yoursite.com/tags/html%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>什么是Canvas，你使用它做个什么需求</title>
    <link href="http://yoursite.com/2020/08/17/%E4%BB%80%E4%B9%88%E6%98%AFCanvas%EF%BC%8C%E4%BD%A0%E4%BD%BF%E7%94%A8%E5%AE%83%E5%81%9A%E4%B8%AA%E4%BB%80%E4%B9%88%E9%9C%80%E6%B1%82/"/>
    <id>http://yoursite.com/2020/08/17/%E4%BB%80%E4%B9%88%E6%98%AFCanvas%EF%BC%8C%E4%BD%A0%E4%BD%BF%E7%94%A8%E5%AE%83%E5%81%9A%E4%B8%AA%E4%BB%80%E4%B9%88%E9%9C%80%E6%B1%82/</id>
    <published>2020-08-17T14:45:29.285Z</published>
    <updated>2020-08-19T09:09:30.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Canvas，你使用它做个什么需求"><a href="#什么是Canvas，你使用它做个什么需求" class="headerlink" title="什么是Canvas，你使用它做个什么需求"></a>什么是Canvas，你使用它做个什么需求</h2><a id="more"></a><h2 id="什么是Canvas"><a href="#什么是Canvas" class="headerlink" title="什么是Canvas"></a><strong>什么是Canvas</strong></h2><p>: Canvas元素是HTML5的一部分，允许脚本语言动态渲染位图像。Canvas由一个可绘制地区HTML代码中的属性定义决定高度和宽度。JavaScript代码可以访问该地区，通过一套完整的绘图功能类似于其他通用二维的API，从而生成动态的图形。<br>Canvas能应对以下需求：</p><h2 id="1-游戏："><a href="#1-游戏：" class="headerlink" title="1. 游戏："></a><strong>1. 游戏：</strong></h2><p>毫无疑问，游戏在HTML5领域具有举足轻重的地位。HTML5在基于Web的图像显示方面比Flash更加立体、更加精巧，Ohad认为运用Canvas制作的图像能够令HTML5游戏在流畅度和跨平台方面发挥更大的潜力。</p><h2 id="2-图表制作："><a href="#2-图表制作：" class="headerlink" title="2. 图表制作："></a><strong>2. 图表制作</strong>：</h2><p>图表制作时常被人们忽略，但无论企业内部还是企业间交流合作都离不开图表。现在一些开发者使用HTML/CSS完成图标制作，但完全可以用Canvas来实现。当然，使用SVG（可缩放矢量图形）来完成图表制作也是非常好的方法。(例如：echarts.js heightchart.js都是基于canvas来绘图!)</p><h2 id="3-banner广告："><a href="#3-banner广告：" class="headerlink" title="3. banner广告："></a><strong>3. banner广告：</strong></h2><p>Flash曾经辉煌的时代，智能手机还未曾出现。现在以及未来的智能机时代，HTML5技术能够在banner广告上发挥巨大作用，用Canvas实现动态的广告效果再合适不过。<br>提示：其实还有很多领域（例如：模拟器 / 远程计算机控制 / 字体设计 / 图像编辑器 / 其它），但是就当前来说，基于canvas图表制作是我们必须要掌握的能力。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是Canvas，你使用它做个什么需求&quot;&gt;&lt;a href=&quot;#什么是Canvas，你使用它做个什么需求&quot; class=&quot;headerlink&quot; title=&quot;什么是Canvas，你使用它做个什么需求&quot;&gt;&lt;/a&gt;什么是Canvas，你使用它做个什么需求&lt;/h2&gt;</summary>
    
    
    
    <category term="Html" scheme="http://yoursite.com/categories/Html/"/>
    
    
    <category term="html基础" scheme="http://yoursite.com/tags/html%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>工作中你都兼容哪些浏览器 ， 实际开发中你都遇到过哪些兼容问题 。</title>
    <link href="http://yoursite.com/2020/08/17/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BD%A0%E9%83%BD%E5%85%BC%E5%AE%B9%E5%93%AA%E4%BA%9B%E6%B5%8F%E8%A7%88%E5%99%A8%20%EF%BC%8C%20%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%A0%E9%83%BD%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%20%E3%80%82/"/>
    <id>http://yoursite.com/2020/08/17/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BD%A0%E9%83%BD%E5%85%BC%E5%AE%B9%E5%93%AA%E4%BA%9B%E6%B5%8F%E8%A7%88%E5%99%A8%20%EF%BC%8C%20%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%A0%E9%83%BD%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%20%E3%80%82/</id>
    <published>2020-08-17T14:45:29.276Z</published>
    <updated>2020-08-19T09:09:19.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工作中你都兼容哪些浏览器-，-实际开发中你都遇到过哪些兼容问题-。"><a href="#工作中你都兼容哪些浏览器-，-实际开发中你都遇到过哪些兼容问题-。" class="headerlink" title="工作中你都兼容哪些浏览器 ， 实际开发中你都遇到过哪些兼容问题 。"></a>工作中你都兼容哪些浏览器 ， 实际开发中你都遇到过哪些兼容问题 。</h2><a id="more"></a><p>Input的按钮在ios和Android中的样式兼容问题<br>ios有默认的渲染 方式 渐变和圆角而且他的行高并不会随着内容的增加。<br>解决方法：<br>在标签上增加<br>-webkie-appearance：none；<br>Height：4rem；<br>滚动穿透的问题:<br>    滚动穿透是指在移动端当有flxed 遮罩和弹出层的时候，屏幕上的滑动能够滑动背景下的内容。<br>最后的解决方法<br><img src="https://img-blog.csdnimg.cn/20200817222716337.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;工作中你都兼容哪些浏览器-，-实际开发中你都遇到过哪些兼容问题-。&quot;&gt;&lt;a href=&quot;#工作中你都兼容哪些浏览器-，-实际开发中你都遇到过哪些兼容问题-。&quot; class=&quot;headerlink&quot; title=&quot;工作中你都兼容哪些浏览器 ， 实际开发中你都遇到过哪些兼容问题 。&quot;&gt;&lt;/a&gt;工作中你都兼容哪些浏览器 ， 实际开发中你都遇到过哪些兼容问题 。&lt;/h2&gt;</summary>
    
    
    
    <category term="Html" scheme="http://yoursite.com/categories/Html/"/>
    
    
    <category term="html基础" scheme="http://yoursite.com/tags/html%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTML 废弃的标签有哪些 ？举几个例子</title>
    <link href="http://yoursite.com/2020/08/17/%E5%BA%9F%E5%BC%83%E7%9A%84%E6%A0%87%E7%AD%BE%E6%9C%89%E5%93%AA%E4%BA%9B%20%EF%BC%9F%E4%B8%BE%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2020/08/17/%E5%BA%9F%E5%BC%83%E7%9A%84%E6%A0%87%E7%AD%BE%E6%9C%89%E5%93%AA%E4%BA%9B%20%EF%BC%9F%E4%B8%BE%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90/</id>
    <published>2020-08-17T14:45:29.260Z</published>
    <updated>2020-08-19T09:09:12.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML-废弃的标签有哪些-？举几个例子"><a href="#HTML-废弃的标签有哪些-？举几个例子" class="headerlink" title="HTML 废弃的标签有哪些 ？举几个例子"></a>HTML 废弃的标签有哪些 ？举几个例子</h2><a id="more"></a><table><thead><tr><th>em=i</th><th>定义强调的文字。</th></tr></thead><tbody><tr><td>ins=u</td><td>定义插入的文字。</td></tr><tr><td>strong=b</td><td>定义重要性强调的文字。</td></tr><tr><td>del=s</td><td>定义删除的文字。</td></tr></tbody></table><p>因为strong,em,ins,del这些标签有语意，所以是b,i,u,s的替代品。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;HTML-废弃的标签有哪些-？举几个例子&quot;&gt;&lt;a href=&quot;#HTML-废弃的标签有哪些-？举几个例子&quot; class=&quot;headerlink&quot; title=&quot;HTML 废弃的标签有哪些 ？举几个例子&quot;&gt;&lt;/a&gt;HTML 废弃的标签有哪些 ？举几个例子&lt;/h2&gt;</summary>
    
    
    
    <category term="Html" scheme="http://yoursite.com/categories/Html/"/>
    
    
    <category term="html基础" scheme="http://yoursite.com/tags/html%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Meta viewport 的原理是什么</title>
    <link href="http://yoursite.com/2020/08/17/Meta%20viewport%20%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2020/08/17/Meta%20viewport%20%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-08-17T14:45:29.239Z</published>
    <updated>2020-08-19T09:10:02.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Meta-viewport-的原理是什么"><a href="#Meta-viewport-的原理是什么" class="headerlink" title="Meta viewport 的原理是什么"></a>Meta viewport 的原理是什么</h2><a id="more"></a><p>手机浏览器是把页面放在一个虚拟的“窗口”（viewport）中，通常这个虚拟的“窗口”（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Meta-viewport-的原理是什么&quot;&gt;&lt;a href=&quot;#Meta-viewport-的原理是什么&quot; class=&quot;headerlink&quot; title=&quot;Meta viewport 的原理是什么&quot;&gt;&lt;/a&gt;Meta viewport 的原理是什么&lt;/h2&gt;</summary>
    
    
    
    <category term="Html" scheme="http://yoursite.com/categories/Html/"/>
    
    
    <category term="html基础" scheme="http://yoursite.com/tags/html%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTML模板语言有哪些</title>
    <link href="http://yoursite.com/2020/08/17/HTML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%20/"/>
    <id>http://yoursite.com/2020/08/17/HTML%E6%A8%A1%E6%9D%BF%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%20/</id>
    <published>2020-08-17T14:45:29.217Z</published>
    <updated>2020-08-19T09:09:56.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML模板语言有哪些"><a href="#HTML模板语言有哪些" class="headerlink" title="HTML模板语言有哪些"></a>HTML模板语言有哪些</h2><a id="more"></a><p>Django 模板基于Python的一个模板。<br>Python下有许多款不同的 Web 框架。Django是重量级选手中最有代表性的一位。许多成功的网站和APP都基于Django。<br>Django是一个开放源代码的Web应用框架，由Python写成。<br>Django遵守BSD版权，初次发布于2005年7月, 并于2008年9月发布了第一个正式版本1.0 。<br>Django采用了MVC的软件设计模式，即模型M，视图V和控制器C。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;HTML模板语言有哪些&quot;&gt;&lt;a href=&quot;#HTML模板语言有哪些&quot; class=&quot;headerlink&quot; title=&quot;HTML模板语言有哪些&quot;&gt;&lt;/a&gt;HTML模板语言有哪些&lt;/h2&gt;</summary>
    
    
    
    <category term="Html" scheme="http://yoursite.com/categories/Html/"/>
    
    
    <category term="html基础" scheme="http://yoursite.com/tags/html%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
